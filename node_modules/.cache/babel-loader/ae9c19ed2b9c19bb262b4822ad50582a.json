{"ast":null,"code":"import { __assign } from \"tslib\";\nimport getArcParams from '@antv/g-canvas/lib/util/arc-params';\nimport { isNumberEqual, isEqual } from '@antv/util';\nimport { getArcPath, getSectorPath } from '../../util/graphics';\n\nfunction getAngle(startPoint, arcPath) {\n  var _a;\n\n  var _b = getArcParams(startPoint, arcPath),\n      startAngle = _b.startAngle,\n      endAngle = _b.endAngle;\n\n  if (!isNumberEqual(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {\n    startAngle += Math.PI * 2;\n  }\n\n  if (!isNumberEqual(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {\n    endAngle += Math.PI * 2;\n  }\n\n  if (arcPath[5] === 0) {\n    // 逆时针，需要将 startAngle 和 endAngle 转置，因为 G2 极坐标系为顺时针方向\n    _a = [endAngle, startAngle], startAngle = _a[0], endAngle = _a[1];\n  }\n\n  if (isNumberEqual(startAngle, Math.PI * 1.5)) {\n    startAngle = Math.PI * -0.5;\n  }\n\n  if (isNumberEqual(endAngle, Math.PI * -0.5)) {\n    endAngle = Math.PI * 1.5;\n  }\n\n  return {\n    startAngle: startAngle,\n    endAngle: endAngle\n  };\n}\n\nfunction getArcStartPoint(path) {\n  var startPoint;\n\n  if (path[0] === 'M' || path[0] === 'L') {\n    startPoint = [path[1], path[2]];\n  } else if (path[0] === 'a' || path[0] === 'A') {\n    startPoint = [path[path.length - 2], path[path.length - 1]];\n  }\n\n  return startPoint;\n}\n/**\n * path 存在以下情况\n * 1. 饼图不为整圆的 path，命令为 M, L, A, L, Z\n * 2. 饼图为整圆的 path，命令为 M, M, A, A, M, Z\n * 3. 环图不为整圆的 path，命令为 M, A, L, A, L, Z\n * 4. 环图为整圆的 path，命令为 M, A, A, M, A, A, M, Z\n * 5. radial-line, 不为整圆时的 path, 命令为 M, A, A, Z\n * 6. radial-line, 为整圆时的 path，命令为 M, A, A, A, A, Z\n * @param path theta 坐标系下圆弧的 path 命令\n */\n\n\nfunction getArcInfo(path) {\n  var _a;\n\n  var startAngle;\n  var endAngle;\n  var arcPaths = path.filter(function (command) {\n    return command[0] === 'A' || command[0] === 'a';\n  });\n  var firstArcPathCommand = arcPaths[0];\n  var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];\n  var firstIndex = path.indexOf(firstArcPathCommand);\n  var lastIndex = path.indexOf(lastArcPathCommand);\n  var firstStartPoint = getArcStartPoint(path[firstIndex - 1]);\n  var lastStartPoint = getArcStartPoint(path[lastIndex - 1]);\n\n  var _b = getAngle(firstStartPoint, firstArcPathCommand),\n      firstStartAngle = _b.startAngle,\n      firstEndAngle = _b.endAngle;\n\n  var _c = getAngle(lastStartPoint, lastArcPathCommand),\n      lastStartAngle = _c.startAngle,\n      lastEndAngle = _c.endAngle;\n\n  if (isNumberEqual(firstStartAngle, lastStartAngle) && isNumberEqual(firstEndAngle, lastEndAngle)) {\n    startAngle = firstStartAngle;\n    endAngle = firstEndAngle;\n  } else {\n    startAngle = Math.min(firstStartAngle, lastStartAngle);\n    endAngle = Math.max(firstEndAngle, lastEndAngle);\n  }\n\n  var radius = firstArcPathCommand[1];\n  var innerRadius = arcPaths[arcPaths.length - 1][1];\n\n  if (radius < innerRadius) {\n    _a = [innerRadius, radius], radius = _a[0], innerRadius = _a[1];\n  } else if (radius === innerRadius) {\n    innerRadius = 0;\n  }\n\n  return {\n    startAngle: startAngle,\n    endAngle: endAngle,\n    radius: radius,\n    innerRadius: innerRadius\n  };\n}\n/**\n * @ignore\n * 饼图更新动画\n * @param shape 文本图形\n * @param animateCfg\n * @param cfg\n */\n\n\nexport function sectorPathUpdate(shape, animateCfg, cfg) {\n  var toAttrs = cfg.toAttrs,\n      coordinate = cfg.coordinate; // @ts-ignore\n\n  var path = toAttrs.path;\n  var pathCommands = path.map(function (command) {\n    return command[0];\n  });\n\n  var _a = getArcInfo(path),\n      curStartAngle = _a.startAngle,\n      curEndAngle = _a.endAngle,\n      radius = _a.radius,\n      innerRadius = _a.innerRadius;\n\n  var _b = getArcInfo(shape.attr('path')),\n      preStartAngle = _b.startAngle,\n      preEndAngle = _b.endAngle;\n\n  var center = coordinate.getCenter();\n  var diffStartAngle = curStartAngle - preStartAngle;\n  var diffEndAngle = curEndAngle - preEndAngle;\n  shape.animate(function (ratio) {\n    var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;\n    var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;\n    return __assign(__assign({}, toAttrs), {\n      path: // hack, 兼容 /examples/bar/basic/demo/radial-line.ts 动画\n      isEqual(pathCommands, ['M', 'A', 'A', 'Z']) ? getArcPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle) : getSectorPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius)\n    });\n  }, __assign(__assign({}, animateCfg), {\n    callback: function callback() {\n      // 将 path 保持原始态，否则会影响 setState() 的动画\n      shape.attr('path', path);\n    }\n  }));\n}","map":{"version":3,"sources":["../../../src/animate/animation/sector-path-update.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\nimport getArcParams from '@antv/g-canvas/lib/util/arc-params';\nimport { isNumberEqual, isEqual } from '@antv/util';\nimport { getArcPath, getSectorPath } from '../../util/graphics';\nfunction getAngle(startPoint, arcPath) {\n    var _a;\n    var _b = getArcParams(startPoint, arcPath), startAngle = _b.startAngle, endAngle = _b.endAngle;\n    if (!isNumberEqual(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {\n        startAngle += Math.PI * 2;\n    }\n    if (!isNumberEqual(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {\n        endAngle += Math.PI * 2;\n    }\n    if (arcPath[5] === 0) {\n        // 逆时针，需要将 startAngle 和 endAngle 转置，因为 G2 极坐标系为顺时针方向\n        _a = [endAngle, startAngle], startAngle = _a[0], endAngle = _a[1];\n    }\n    if (isNumberEqual(startAngle, Math.PI * 1.5)) {\n        startAngle = Math.PI * -0.5;\n    }\n    if (isNumberEqual(endAngle, Math.PI * -0.5)) {\n        endAngle = Math.PI * 1.5;\n    }\n    return {\n        startAngle: startAngle,\n        endAngle: endAngle,\n    };\n}\nfunction getArcStartPoint(path) {\n    var startPoint;\n    if (path[0] === 'M' || path[0] === 'L') {\n        startPoint = [path[1], path[2]];\n    }\n    else if (path[0] === 'a' || path[0] === 'A') {\n        startPoint = [path[path.length - 2], path[path.length - 1]];\n    }\n    return startPoint;\n}\n/**\n * path 存在以下情况\n * 1. 饼图不为整圆的 path，命令为 M, L, A, L, Z\n * 2. 饼图为整圆的 path，命令为 M, M, A, A, M, Z\n * 3. 环图不为整圆的 path，命令为 M, A, L, A, L, Z\n * 4. 环图为整圆的 path，命令为 M, A, A, M, A, A, M, Z\n * 5. radial-line, 不为整圆时的 path, 命令为 M, A, A, Z\n * 6. radial-line, 为整圆时的 path，命令为 M, A, A, A, A, Z\n * @param path theta 坐标系下圆弧的 path 命令\n */\nfunction getArcInfo(path) {\n    var _a;\n    var startAngle;\n    var endAngle;\n    var arcPaths = path.filter(function (command) {\n        return command[0] === 'A' || command[0] === 'a';\n    });\n    var firstArcPathCommand = arcPaths[0];\n    var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];\n    var firstIndex = path.indexOf(firstArcPathCommand);\n    var lastIndex = path.indexOf(lastArcPathCommand);\n    var firstStartPoint = getArcStartPoint(path[firstIndex - 1]);\n    var lastStartPoint = getArcStartPoint(path[lastIndex - 1]);\n    var _b = getAngle(firstStartPoint, firstArcPathCommand), firstStartAngle = _b.startAngle, firstEndAngle = _b.endAngle;\n    var _c = getAngle(lastStartPoint, lastArcPathCommand), lastStartAngle = _c.startAngle, lastEndAngle = _c.endAngle;\n    if (isNumberEqual(firstStartAngle, lastStartAngle) && isNumberEqual(firstEndAngle, lastEndAngle)) {\n        startAngle = firstStartAngle;\n        endAngle = firstEndAngle;\n    }\n    else {\n        startAngle = Math.min(firstStartAngle, lastStartAngle);\n        endAngle = Math.max(firstEndAngle, lastEndAngle);\n    }\n    var radius = firstArcPathCommand[1];\n    var innerRadius = arcPaths[arcPaths.length - 1][1];\n    if (radius < innerRadius) {\n        _a = [innerRadius, radius], radius = _a[0], innerRadius = _a[1];\n    }\n    else if (radius === innerRadius) {\n        innerRadius = 0;\n    }\n    return {\n        startAngle: startAngle,\n        endAngle: endAngle,\n        radius: radius,\n        innerRadius: innerRadius,\n    };\n}\n/**\n * @ignore\n * 饼图更新动画\n * @param shape 文本图形\n * @param animateCfg\n * @param cfg\n */\nexport function sectorPathUpdate(shape, animateCfg, cfg) {\n    var toAttrs = cfg.toAttrs, coordinate = cfg.coordinate;\n    // @ts-ignore\n    var path = toAttrs.path;\n    var pathCommands = path.map(function (command) { return command[0]; });\n    var _a = getArcInfo(path), curStartAngle = _a.startAngle, curEndAngle = _a.endAngle, radius = _a.radius, innerRadius = _a.innerRadius;\n    var _b = getArcInfo(shape.attr('path')), preStartAngle = _b.startAngle, preEndAngle = _b.endAngle;\n    var center = coordinate.getCenter();\n    var diffStartAngle = curStartAngle - preStartAngle;\n    var diffEndAngle = curEndAngle - preEndAngle;\n    shape.animate(function (ratio) {\n        var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;\n        var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;\n        return __assign(__assign({}, toAttrs), { path: \n            // hack, 兼容 /examples/bar/basic/demo/radial-line.ts 动画\n            isEqual(pathCommands, ['M', 'A', 'A', 'Z'])\n                ? getArcPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle)\n                : getSectorPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius) });\n    }, __assign(__assign({}, animateCfg), { callback: function () {\n            // 将 path 保持原始态，否则会影响 setState() 的动画\n            shape.attr('path', path);\n        } }));\n}\n//# sourceMappingURL=sector-path-update.js.map"]},"metadata":{},"sourceType":"module"}