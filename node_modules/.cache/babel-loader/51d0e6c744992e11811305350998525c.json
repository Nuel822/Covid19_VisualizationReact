{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { each, isArray } from '@antv/util';\nimport { registerShape, registerShapeFactory } from '../base';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\nimport { splitPoints } from '../util/split-points';\nimport { getLineMarker } from './util';\n\nfunction getShapeAttrs(cfg, smooth, constraint) {\n  var isStack = cfg.isStack,\n      connectNulls = cfg.connectNulls,\n      isInCircle = cfg.isInCircle;\n  var points = getPathPoints(cfg.points, connectNulls); // 根据 connectNulls 值处理 points\n\n  var path = [];\n  each(points, function (eachLinePoints) {\n    path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint));\n  });\n  return __assign(__assign({}, getStyle(cfg, true, false, 'lineWidth')), {\n    path: path\n  });\n} // 单条 path\n\n\nfunction getSinglePath(points, isInCircle, smooth, constraint) {\n  var path;\n\n  if (!smooth) {\n    path = getLinePath(points, false);\n\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  } else {\n    // 直角坐标系下绘制曲线时限制最大值、最小值\n    if (isInCircle && points.length) {\n      points.push({\n        x: points[0].x,\n        y: points[0].y\n      });\n    }\n\n    path = getSplinePath(points, false, constraint);\n  }\n\n  return path;\n}\n\nfunction getRangePath(points, isInCircle, isStack, smooth, constraint) {\n  var topPoints = [];\n  var bottomPoints = [];\n  each(points, function (point) {\n    var result = splitPoints(point);\n    topPoints.push(result[1]); // 上边\n\n    bottomPoints.push(result[0]); // 底边\n  });\n  var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint);\n  var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint);\n\n  if (isStack) {\n    return topPath;\n  }\n\n  return topPath.concat(bottomPath);\n}\n\nfunction getPath(points, isInCircle, isStack, smooth, constraint) {\n  var first = points[0];\n  return isArray(first.y) ? getRangePath(points, isInCircle, isStack, smooth, constraint) : getSinglePath(points, isInCircle, smooth, constraint);\n}\n\nvar LineShapeFactory = registerShapeFactory('line', {\n  defaultShapeType: 'line'\n}); // 这里因为代码公用，所以直接全部注册\n// 'line' 默认折线；'dot' 点线 ···；'dash' 断线 - - -\n\neach(['line', 'dot', 'dash', 'smooth'], function (shapeType) {\n  registerShape('line', shapeType, {\n    draw: function draw(cfg, container) {\n      var smooth = shapeType === 'smooth';\n      var constraint;\n\n      if (smooth) {\n        var _a = this.coordinate,\n            start = _a.start,\n            end = _a.end;\n        constraint = [[start.x, end.y], [end.x, start.y]];\n      }\n\n      var attrs = getShapeAttrs(cfg, smooth, constraint);\n      var shape = container.addShape({\n        type: 'path',\n        attrs: attrs,\n        name: 'line'\n      });\n      return shape;\n    },\n    getMarker: function getMarker(markerCfg) {\n      return getLineMarker(markerCfg, shapeType);\n    }\n  });\n});\nexport default LineShapeFactory;","map":{"version":3,"sources":["../../../../src/geometry/shape/line/index.ts"],"names":[],"mappings":";AAAA,SAAS,IAAT,EAAe,OAAf,QAA8B,YAA9B;AAIA,SAAS,aAAT,EAAwB,oBAAxB,QAAoD,SAApD;AACA,SAAS,aAAT,QAA8B,yBAA9B;AACA,SAAS,QAAT,QAAyB,mBAAzB;AACA,SAAS,WAAT,EAAsB,aAAtB,QAA2C,cAA3C;AACA,SAAS,WAAT,QAA4B,sBAA5B;AACA,SAAS,aAAT,QAA8B,QAA9B;;AAEA,SAAS,aAAT,CAAuB,GAAvB,EAAuC,MAAvC,EAAyD,UAAzD,EAAgF;AACtE,MAAA,OAAA,GAAA,GAAA,CAAA,OAAA;AAAA,MAAS,YAAA,GAAA,GAAA,CAAA,YAAT;AAAA,MAAuB,UAAA,GAAA,GAAA,CAAA,UAAvB;AACR,MAAM,MAAM,GAAG,aAAa,CAAC,GAAG,CAAC,MAAL,EAAa,YAAb,CAA5B,CAF8E,CAEtB;;AAExD,MAAI,IAAI,GAAG,EAAX;AACA,EAAA,IAAI,CAAC,MAAD,EAAS,UAAC,cAAD,EAAuC;AAClD,IAAA,IAAI,GAAG,IAAI,CAAC,MAAL,CAAY,OAAO,CAAC,cAAD,EAAiB,UAAjB,EAA6B,OAA7B,EAAsC,MAAtC,EAA8C,UAA9C,CAAnB,CAAP;AACD,GAFG,CAAJ;AAIA,SAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACK,QAAQ,CAAC,GAAD,EAAM,IAAN,EAAY,KAAZ,EAAmB,WAAnB,CADb,CAAA,EAC4C;AAC1C,IAAA,IAAI,EAAA;AADsC,GAD5C,CAAA;AAID,C,CAED;;;AACA,SAAS,aAAT,CAAuB,MAAvB,EAAwC,UAAxC,EAA6D,MAA7D,EAA+E,UAA/E,EAAsG;AACpG,MAAI,IAAJ;;AACA,MAAI,CAAC,MAAL,EAAa;AACX,IAAA,IAAI,GAAG,WAAW,CAAC,MAAD,EAAS,KAAT,CAAlB;;AACA,QAAI,UAAJ,EAAgB;AACd,MAAA,IAAI,CAAC,IAAL,CAAU,CAAC,GAAD,CAAV;AACD;AACF,GALD,MAKO;AACL;AACA,QAAI,UAAU,IAAI,MAAM,CAAC,MAAzB,EAAiC;AAC/B,MAAA,MAAM,CAAC,IAAP,CAAY;AAAE,QAAA,CAAC,EAAE,MAAM,CAAC,CAAD,CAAN,CAAU,CAAf;AAAkB,QAAA,CAAC,EAAE,MAAM,CAAC,CAAD,CAAN,CAAU;AAA/B,OAAZ;AACD;;AACD,IAAA,IAAI,GAAG,aAAa,CAAC,MAAD,EAAS,KAAT,EAAgB,UAAhB,CAApB;AACD;;AAED,SAAO,IAAP;AACD;;AAED,SAAS,YAAT,CACE,MADF,EAEE,UAFF,EAGE,OAHF,EAIE,MAJF,EAKE,UALF,EAKyB;AAEvB,MAAM,SAAS,GAAG,EAAlB;AACA,MAAM,YAAY,GAAG,EAArB;AACA,EAAA,IAAI,CAAC,MAAD,EAAS,UAAC,KAAD,EAAkB;AAC7B,QAAM,MAAM,GAAG,WAAW,CAAC,KAAD,CAA1B;AACA,IAAA,SAAS,CAAC,IAAV,CAAe,MAAM,CAAC,CAAD,CAArB,EAF6B,CAEF;;AAC3B,IAAA,YAAY,CAAC,IAAb,CAAkB,MAAM,CAAC,CAAD,CAAxB,EAH6B,CAGC;AAC/B,GAJG,CAAJ;AAMA,MAAM,OAAO,GAAG,aAAa,CAAC,SAAD,EAAY,UAAZ,EAAwB,MAAxB,EAAgC,UAAhC,CAA7B;AACA,MAAM,UAAU,GAAG,aAAa,CAAC,YAAD,EAAe,UAAf,EAA2B,MAA3B,EAAmC,UAAnC,CAAhC;;AACA,MAAI,OAAJ,EAAa;AACX,WAAO,OAAP;AACD;;AACD,SAAO,OAAO,CAAC,MAAR,CAAe,UAAf,CAAP;AACD;;AAED,SAAS,OAAT,CACE,MADF,EAEE,UAFF,EAGE,OAHF,EAIE,MAJF,EAKE,UALF,EAKyB;AAEvB,MAAM,KAAK,GAAG,MAAM,CAAC,CAAD,CAApB;AAEA,SAAO,OAAO,CAAC,KAAK,CAAC,CAAP,CAAP,GACH,YAAY,CAAC,MAAD,EAAyB,UAAzB,EAAqC,OAArC,EAA8C,MAA9C,EAAsD,UAAtD,CADT,GAEH,aAAa,CAAC,MAAD,EAAoB,UAApB,EAAgC,MAAhC,EAAwC,UAAxC,CAFjB;AAGD;;AAED,IAAM,gBAAgB,GAAG,oBAAoB,CAAC,MAAD,EAAS;AACpD,EAAA,gBAAgB,EAAE;AADkC,CAAT,CAA7C,C,CAIA;AACA;;AACA,IAAI,CAAC,CAAC,MAAD,EAAS,KAAT,EAAgB,MAAhB,EAAwB,QAAxB,CAAD,EAAoC,UAAC,SAAD,EAAU;AAChD,EAAA,aAAa,CAAC,MAAD,EAAS,SAAT,EAAoB;AAC/B,IAAA,IAAI,EAAJ,cAAK,GAAL,EAAqB,SAArB,EAAsC;AACpC,UAAM,MAAM,GAAG,SAAS,KAAK,QAA7B;AACA,UAAI,UAAJ;;AACA,UAAI,MAAJ,EAAY;AACJ,YAAA,EAAA,GAAA,KAAA,UAAA;AAAA,YAAE,KAAA,GAAA,EAAA,CAAA,KAAF;AAAA,YAAS,GAAA,GAAA,EAAA,CAAA,GAAT;AACN,QAAA,UAAU,GAAG,CACX,CAAC,KAAK,CAAC,CAAP,EAAU,GAAG,CAAC,CAAd,CADW,EAEX,CAAC,GAAG,CAAC,CAAL,EAAQ,KAAK,CAAC,CAAd,CAFW,CAAb;AAID;;AAED,UAAM,KAAK,GAAG,aAAa,CAAC,GAAD,EAAM,MAAN,EAAc,UAAd,CAA3B;AACA,UAAM,KAAK,GAAG,SAAS,CAAC,QAAV,CAAmB;AAC/B,QAAA,IAAI,EAAE,MADyB;AAE/B,QAAA,KAAK,EAAA,KAF0B;AAG/B,QAAA,IAAI,EAAE;AAHyB,OAAnB,CAAd;AAMA,aAAO,KAAP;AACD,KApB8B;AAqB/B,IAAA,SAAS,EAAT,mBAAU,SAAV,EAAmC;AACjC,aAAO,aAAa,CAAC,SAAD,EAAY,SAAZ,CAApB;AACD;AAvB8B,GAApB,CAAb;AAyBD,CA1BG,CAAJ;AA4BA,eAAe,gBAAf","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\nimport { each, isArray } from '@antv/util';\nimport { registerShape, registerShapeFactory } from '../base';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\nimport { splitPoints } from '../util/split-points';\nimport { getLineMarker } from './util';\nfunction getShapeAttrs(cfg, smooth, constraint) {\n    var isStack = cfg.isStack, connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle;\n    var points = getPathPoints(cfg.points, connectNulls); // 根据 connectNulls 值处理 points\n    var path = [];\n    each(points, function (eachLinePoints) {\n        path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint));\n    });\n    return __assign(__assign({}, getStyle(cfg, true, false, 'lineWidth')), { path: path });\n}\n// 单条 path\nfunction getSinglePath(points, isInCircle, smooth, constraint) {\n    var path;\n    if (!smooth) {\n        path = getLinePath(points, false);\n        if (isInCircle) {\n            path.push(['Z']);\n        }\n    }\n    else {\n        // 直角坐标系下绘制曲线时限制最大值、最小值\n        if (isInCircle && points.length) {\n            points.push({ x: points[0].x, y: points[0].y });\n        }\n        path = getSplinePath(points, false, constraint);\n    }\n    return path;\n}\nfunction getRangePath(points, isInCircle, isStack, smooth, constraint) {\n    var topPoints = [];\n    var bottomPoints = [];\n    each(points, function (point) {\n        var result = splitPoints(point);\n        topPoints.push(result[1]); // 上边\n        bottomPoints.push(result[0]); // 底边\n    });\n    var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint);\n    var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint);\n    if (isStack) {\n        return topPath;\n    }\n    return topPath.concat(bottomPath);\n}\nfunction getPath(points, isInCircle, isStack, smooth, constraint) {\n    var first = points[0];\n    return isArray(first.y)\n        ? getRangePath(points, isInCircle, isStack, smooth, constraint)\n        : getSinglePath(points, isInCircle, smooth, constraint);\n}\nvar LineShapeFactory = registerShapeFactory('line', {\n    defaultShapeType: 'line',\n});\n// 这里因为代码公用，所以直接全部注册\n// 'line' 默认折线；'dot' 点线 ···；'dash' 断线 - - -\neach(['line', 'dot', 'dash', 'smooth'], function (shapeType) {\n    registerShape('line', shapeType, {\n        draw: function (cfg, container) {\n            var smooth = shapeType === 'smooth';\n            var constraint;\n            if (smooth) {\n                var _a = this.coordinate, start = _a.start, end = _a.end;\n                constraint = [\n                    [start.x, end.y],\n                    [end.x, start.y],\n                ];\n            }\n            var attrs = getShapeAttrs(cfg, smooth, constraint);\n            var shape = container.addShape({\n                type: 'path',\n                attrs: attrs,\n                name: 'line',\n            });\n            return shape;\n        },\n        getMarker: function (markerCfg) {\n            return getLineMarker(markerCfg, shapeType);\n        },\n    });\n});\nexport default LineShapeFactory;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}