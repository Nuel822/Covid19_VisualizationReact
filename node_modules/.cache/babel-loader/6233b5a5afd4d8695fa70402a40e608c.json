{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { deepMix, each, find, get, head, isBoolean, last, map } from '@antv/util';\nimport { COMPONENT_MAX_VIEW_PERCENTAGE, COMPONENT_TYPE, DIRECTION, LAYER } from '../../constant';\nimport { CategoryLegend, ContinuousLegend } from '../../dependents';\nimport { DEFAULT_ANIMATE_CFG } from '../../animate';\nimport { BBox } from '../../util/bbox';\nimport { directionToPosition } from '../../util/direction';\nimport { omit } from '../../util/helper';\nimport { getCustomLegendItems, getLegendItems, getLegendLayout } from '../../util/legend';\nimport { getName } from '../../util/scale';\nimport { Controller } from './base';\n/**\n * 从配置中获取单个字段的 legend 配置\n * @param legends\n * @param field\n * @returns the option of one legend field\n */\n\nfunction getLegendOption(legends, field) {\n  if (isBoolean(legends)) {\n    return legends === false ? false : {};\n  }\n\n  return get(legends, [field], legends);\n}\n\nfunction getDirection(legendOption) {\n  return get(legendOption, 'position', DIRECTION.BOTTOM);\n}\n/**\n * @ignore\n * legend Controller\n */\n\n\nvar Legend =\n/** @class */\nfunction (_super) {\n  __extends(Legend, _super);\n\n  function Legend(view) {\n    var _this = _super.call(this, view) || this;\n\n    _this.container = _this.view.getLayer(LAYER.FORE).addGroup();\n    return _this;\n  }\n\n  Object.defineProperty(Legend.prototype, \"name\", {\n    get: function () {\n      return 'legend';\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Legend.prototype.init = function () {};\n  /**\n   * render the legend component by legend options\n   */\n\n\n  Legend.prototype.render = function () {\n    var _this = this;\n\n    this.option = this.view.getOptions().legends;\n\n    var doEachLegend = function (geometry, attr, scale) {\n      var legend = _this.createFieldLegend(geometry, attr, scale);\n\n      if (legend) {\n        legend.component.init();\n\n        _this.components.push(legend);\n      }\n    }; // 全局自定义图例\n\n\n    if (get(this.option, 'custom')) {\n      var component = this.createCustomLegend(undefined, undefined, undefined, this.option);\n\n      if (component) {\n        component.init();\n        var layer = LAYER.FORE;\n        var direction = getDirection(this.option);\n        this.components.push({\n          id: 'global-custom',\n          component: component,\n          layer: layer,\n          direction: direction,\n          type: COMPONENT_TYPE.LEGEND,\n          extra: undefined\n        });\n      }\n    } else {\n      // 遍历处理每一个创建逻辑\n      this.loopLegends(doEachLegend);\n    }\n  };\n  /**\n   * layout legend\n   * 计算出 legend 的 direction 位置 x, y\n   */\n\n\n  Legend.prototype.layout = function () {\n    var _this = this;\n\n    this.layoutBBox = this.view.viewBBox;\n    each(this.components, function (co) {\n      var component = co.component,\n          direction = co.direction;\n      var layout = getLegendLayout(direction);\n\n      var maxSize = _this.getCategoryLegendSizeCfg(layout);\n\n      var maxWidth = component.get('maxWidth');\n      var maxHeight = component.get('maxHeight'); // 先更新 maxSize，更新 layoutBBox，以便计算正确的 x y\n\n      component.update({\n        maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),\n        maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0)\n      });\n      var bboxObject = component.getLayoutBBox(); // 这里只需要他的 width、height 信息做位置调整\n\n      var bbox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);\n\n      var _a = directionToPosition(_this.view.coordinateBBox, bbox, direction),\n          x1 = _a[0],\n          y1 = _a[1];\n\n      var _b = directionToPosition(_this.layoutBBox, bbox, direction),\n          x2 = _b[0],\n          y2 = _b[1];\n\n      var x = 0;\n      var y = 0; // 因为 legend x y 要和 coordinateBBox 对齐，所以要做一个简单的判断\n\n      if (direction.startsWith('top') || direction.startsWith('bottom')) {\n        x = x1;\n        y = y2;\n      } else {\n        x = x2;\n        y = y1;\n      } // 更新位置\n\n\n      component.update({\n        x: x,\n        y: y\n      });\n      _this.layoutBBox = _this.layoutBBox.cut(bbox, direction);\n    });\n  };\n  /**\n   * legend 的更新逻辑\n   */\n\n\n  Legend.prototype.update = function () {\n    var _this = this;\n\n    this.option = this.view.getOptions().legends; // 已经处理过的 legend\n\n    var updated = {};\n\n    var eachLegend = function (geometry, attr, scale) {\n      var id = _this.getId(scale.field);\n\n      var existCo = _this.getComponentById(id); // 存在则 update\n\n\n      if (existCo) {\n        var cfg = void 0;\n        var legendOption = getLegendOption(_this.option, scale.field); // if the legend option is not false, means legend should be created.\n\n        if (legendOption !== false) {\n          if (get(legendOption, 'custom')) {\n            cfg = _this.getCategoryCfg(geometry, attr, scale, legendOption, true);\n          } else {\n            if (scale.isLinear) {\n              // linear field, create continuous legend\n              cfg = _this.getContinuousCfg(geometry, attr, scale, legendOption);\n            } else if (scale.isCategory) {\n              // category field, create category legend\n              cfg = _this.getCategoryCfg(geometry, attr, scale, legendOption);\n            }\n          }\n        } // 如果 cfg 为空，则不在 updated 标记，那么会在后面逻辑中删除\n\n\n        if (cfg) {\n          // omit 掉一些属性，比如 container 等\n          omit(cfg, ['container']);\n          existCo.direction = getDirection(legendOption);\n          existCo.component.update(cfg); // 标记为新的\n\n          updated[id] = true;\n        }\n      } else {\n        // 不存在则 create\n        var legend = _this.createFieldLegend(geometry, attr, scale);\n\n        if (legend) {\n          legend.component.init();\n\n          _this.components.push(legend); // 标记为新的\n\n\n          updated[id] = true;\n        }\n      }\n    }; // 全局自定义图例\n\n\n    if (get(this.option, 'custom')) {\n      var id = 'global-custom';\n      var existCo = this.getComponentById(id);\n\n      if (existCo) {\n        var customCfg = this.getCategoryCfg(undefined, undefined, undefined, this.option, true);\n        omit(customCfg, ['container']);\n        existCo.component.update(customCfg);\n        updated[id] = true;\n      } else {\n        var component = this.createCustomLegend(undefined, undefined, undefined, this.option);\n\n        if (component) {\n          component.init();\n          var layer = LAYER.FORE;\n          var direction = getDirection(this.option);\n          this.components.push({\n            id: id,\n            component: component,\n            layer: layer,\n            direction: direction,\n            type: COMPONENT_TYPE.LEGEND,\n            extra: undefined\n          }); // 标记为更新\n\n          updated[id] = true;\n        }\n      }\n    } else {\n      // 遍历处理每一个创建逻辑\n      this.loopLegends(eachLegend);\n    } // 处理完成之后，销毁删除的\n    // 不在处理中的\n\n\n    var components = [];\n    each(this.getComponents(), function (co) {\n      if (updated[co.id]) {\n        components.push(co);\n      } else {\n        co.component.destroy();\n      }\n    }); // 更新当前已有的 components\n\n    this.components = components;\n  };\n\n  Legend.prototype.clear = function () {\n    _super.prototype.clear.call(this);\n\n    this.container.clear();\n  };\n\n  Legend.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    this.container.remove(true);\n  };\n  /**\n   * 递归获取所有的 Geometry\n   */\n\n\n  Legend.prototype.getGeometries = function (view, geometries) {\n    var _this = this;\n\n    if (geometries === void 0) {\n      geometries = [];\n    } // 首先获得当前 view 的 Geometries\n\n\n    geometries.push.apply(geometries, view.geometries); // 然后递归\n\n    each(view.views, function (v) {\n      return _this.getGeometries(v, geometries);\n    });\n    return geometries;\n  };\n  /**\n   * 遍历 Geometry，处理 legend 逻辑\n   * @param doEach 每个 loop 中的处理方法\n   */\n\n\n  Legend.prototype.loopLegends = function (doEach) {\n    var isRootView = this.view.getRootView() === this.view; // 非根 view，不处理 legend\n\n    if (!isRootView) {\n      return;\n    } // 递归 view 中所有的 Geometry，进行创建 legend\n\n\n    var geometries = this.getGeometries(this.view);\n    var looped = {}; // 防止一个字段创建两个 legend\n\n    each(geometries, function (geometry) {\n      var attributes = geometry.getGroupAttributes();\n      each(attributes, function (attr) {\n        var scale = attr.getScale(attr.type); // 如果在视觉通道上映射常量值，如 size(2) shape('circle') 不创建 legend\n\n        if (!scale || scale.type === 'identity' || looped[scale.field]) {\n          return;\n        }\n\n        doEach(geometry, attr, scale);\n        looped[scale.field] = true;\n      });\n    });\n  };\n  /**\n   * 创建一个 legend\n   * @param geometry\n   * @param attr\n   * @param scale\n   */\n\n\n  Legend.prototype.createFieldLegend = function (geometry, attr, scale) {\n    var component;\n    var legendOption = getLegendOption(this.option, scale.field);\n    var layer = LAYER.FORE;\n    var direction = getDirection(legendOption); // if the legend option is not false, means legend should be created.\n\n    if (legendOption !== false) {\n      if (get(legendOption, 'custom')) {\n        component = this.createCustomLegend(geometry, attr, scale, legendOption);\n      } else {\n        if (scale.isLinear) {\n          // linear field, create continuous legend\n          component = this.createContinuousLegend(geometry, attr, scale, legendOption);\n        } else if (scale.isCategory) {\n          // category field, create category legend\n          component = this.createCategoryLegend(geometry, attr, scale, legendOption);\n        }\n      }\n    }\n\n    if (component) {\n      component.set('field', scale.field);\n      return {\n        id: this.getId(scale.field),\n        component: component,\n        layer: layer,\n        direction: direction,\n        type: COMPONENT_TYPE.LEGEND,\n        extra: {\n          scale: scale\n        }\n      };\n    }\n  };\n  /**\n   * 自定义图例使用 category 图例去渲染\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param legendOption\n   */\n\n\n  Legend.prototype.createCustomLegend = function (geometry, attr, scale, legendOption) {\n    // 直接使用 分类图例渲染\n    var cfg = this.getCategoryCfg(geometry, attr, scale, legendOption, true);\n    return new CategoryLegend(cfg);\n  };\n  /**\n   * 创建连续图例\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param legendOption\n   */\n\n\n  Legend.prototype.createContinuousLegend = function (geometry, attr, scale, legendOption) {\n    var cfg = this.getContinuousCfg(geometry, attr, scale, legendOption);\n    return new ContinuousLegend(cfg);\n  };\n  /**\n   * 创建分类图例\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param legendOption\n   */\n\n\n  Legend.prototype.createCategoryLegend = function (geometry, attr, scale, legendOption) {\n    var cfg = this.getCategoryCfg(geometry, attr, scale, legendOption);\n    return new CategoryLegend(cfg);\n  };\n  /**\n   * 获得连续图例的配置\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param legendOption\n   */\n\n\n  Legend.prototype.getContinuousCfg = function (geometry, attr, scale, legendOption) {\n    var ticks = scale.getTicks();\n    var containMin = find(ticks, function (tick) {\n      return tick.value === 0;\n    });\n    var containMax = find(ticks, function (tick) {\n      return tick.value === 1;\n    });\n    var items = map(ticks, function (tick) {\n      var value = tick.value,\n          tickValue = tick.tickValue;\n      var attrValue = attr.mapping(scale.invert(value)).join('');\n      return {\n        value: tickValue,\n        attrValue: attrValue,\n        color: attrValue,\n        scaleValue: value\n      };\n    });\n\n    if (!containMin) {\n      items.push({\n        value: scale.min,\n        attrValue: attr.mapping(0).join(''),\n        color: attr.mapping(0).join(''),\n        scaleValue: 0\n      });\n    }\n\n    if (!containMax) {\n      items.push({\n        value: scale.max,\n        attrValue: attr.mapping(1).join(''),\n        color: attr.mapping(1).join(''),\n        scaleValue: 1\n      });\n    } // 排序\n\n\n    items.sort(function (a, b) {\n      return a.value - b.value;\n    }); // 跟 attr 相关的配置\n    // size color 区别的配置\n\n    var attrLegendCfg = {\n      min: head(items).value,\n      max: last(items).value,\n      colors: [],\n      rail: {\n        type: attr.type\n      },\n      track: {}\n    };\n\n    if (attr.type === 'size') {\n      attrLegendCfg = __assign(__assign({}, attrLegendCfg), {\n        track: {\n          style: {\n            // size 的选中前景色，对于 color，则直接使用 color 标识\n            // @ts-ignore\n            fill: attr.type === 'size' ? this.view.getTheme().defaultColor : undefined\n          }\n        }\n      });\n    }\n\n    if (attr.type === 'color') {\n      attrLegendCfg = __assign(__assign({}, attrLegendCfg), {\n        colors: map(items, function (item) {\n          return item.attrValue;\n        })\n      });\n    }\n\n    var container = this.container; // if position is not set, use top as default\n\n    var direction = getDirection(legendOption);\n    var layout = getLegendLayout(direction);\n    var title = get(legendOption, 'title');\n\n    if (title) {\n      title = deepMix({\n        text: getName(scale)\n      }, title);\n    } // 基础配置，从当前数据中读到的配置\n\n\n    var baseCfg = __assign(__assign({\n      container: container,\n      layout: layout\n    }, attrLegendCfg), {\n      title: title\n    }); // @ts-ignore\n\n\n    return this.mergeLegendCfg(baseCfg, legendOption, 'continuous');\n  };\n  /**\n   * 获取分类图例的配置项\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param custom\n   * @param legendOption\n   */\n\n\n  Legend.prototype.getCategoryCfg = function (geometry, attr, scale, legendOption, custom) {\n    var container = this.container; // if position is not set, use top as default\n\n    var direction = get(legendOption, 'position', DIRECTION.BOTTOM); // the default marker style\n\n    var themeMarker = get(this.view.getTheme(), ['components', 'legend', direction, 'marker']);\n    var userMarker = get(legendOption, 'marker');\n    var layout = getLegendLayout(direction);\n    var items = custom ? getCustomLegendItems(themeMarker, userMarker, legendOption.items) : getLegendItems(this.view, geometry, attr, themeMarker, userMarker);\n    var title = get(legendOption, 'title');\n\n    if (title) {\n      title = deepMix({\n        text: scale ? getName(scale) : ''\n      }, title);\n    }\n\n    var baseCfg = __assign({\n      container: container,\n      layout: layout,\n      items: items,\n      title: title\n    }, this.getCategoryLegendSizeCfg(layout));\n\n    var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction);\n\n    if (categoryCfg.reversed) {\n      // 图例项需要逆序\n      categoryCfg.items.reverse();\n    }\n\n    return categoryCfg;\n  };\n  /**\n   * get legend config, use option > suggestion > theme\n   * @param baseCfg\n   * @param legendOption\n   * @param direction\n   */\n\n\n  Legend.prototype.mergeLegendCfg = function (baseCfg, legendOption, direction) {\n    var themeObject = get(this.view.getTheme(), ['components', 'legend', direction], {});\n    return deepMix({}, themeObject, baseCfg, {\n      animateOption: DEFAULT_ANIMATE_CFG\n    }, legendOption);\n  };\n  /**\n   * 生成 id\n   * @param key\n   */\n\n\n  Legend.prototype.getId = function (key) {\n    return this.name + \"-\" + key;\n  };\n  /**\n   * 根据 id 来获取组件\n   * @param id\n   */\n\n\n  Legend.prototype.getComponentById = function (id) {\n    return find(this.components, function (co) {\n      return co.id === id;\n    });\n  };\n\n  Legend.prototype.getCategoryLegendSizeCfg = function (layout) {\n    var _a = this.view.viewBBox,\n        vw = _a.width,\n        vh = _a.height;\n    var _b = this.view.coordinateBBox,\n        cw = _b.width,\n        ch = _b.height;\n    return layout === 'vertical' ? {\n      maxWidth: vw * COMPONENT_MAX_VIEW_PERCENTAGE,\n      maxHeight: ch\n    } : {\n      maxWidth: cw,\n      maxHeight: vh * COMPONENT_MAX_VIEW_PERCENTAGE\n    };\n  };\n\n  return Legend;\n}(Controller);\n\nexport default Legend;","map":{"version":3,"sources":["../../../src/chart/controller/legend.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { deepMix, each, find, get, head, isBoolean, last, map } from '@antv/util';\nimport { COMPONENT_MAX_VIEW_PERCENTAGE, COMPONENT_TYPE, DIRECTION, LAYER } from '../../constant';\nimport { CategoryLegend, ContinuousLegend } from '../../dependents';\nimport { DEFAULT_ANIMATE_CFG } from '../../animate';\nimport { BBox } from '../../util/bbox';\nimport { directionToPosition } from '../../util/direction';\nimport { omit } from '../../util/helper';\nimport { getCustomLegendItems, getLegendItems, getLegendLayout } from '../../util/legend';\nimport { getName } from '../../util/scale';\nimport { Controller } from './base';\n/**\n * 从配置中获取单个字段的 legend 配置\n * @param legends\n * @param field\n * @returns the option of one legend field\n */\nfunction getLegendOption(legends, field) {\n    if (isBoolean(legends)) {\n        return legends === false ? false : {};\n    }\n    return get(legends, [field], legends);\n}\nfunction getDirection(legendOption) {\n    return get(legendOption, 'position', DIRECTION.BOTTOM);\n}\n/**\n * @ignore\n * legend Controller\n */\nvar Legend = /** @class */ (function (_super) {\n    __extends(Legend, _super);\n    function Legend(view) {\n        var _this = _super.call(this, view) || this;\n        _this.container = _this.view.getLayer(LAYER.FORE).addGroup();\n        return _this;\n    }\n    Object.defineProperty(Legend.prototype, \"name\", {\n        get: function () {\n            return 'legend';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Legend.prototype.init = function () { };\n    /**\n     * render the legend component by legend options\n     */\n    Legend.prototype.render = function () {\n        var _this = this;\n        this.option = this.view.getOptions().legends;\n        var doEachLegend = function (geometry, attr, scale) {\n            var legend = _this.createFieldLegend(geometry, attr, scale);\n            if (legend) {\n                legend.component.init();\n                _this.components.push(legend);\n            }\n        };\n        // 全局自定义图例\n        if (get(this.option, 'custom')) {\n            var component = this.createCustomLegend(undefined, undefined, undefined, this.option);\n            if (component) {\n                component.init();\n                var layer = LAYER.FORE;\n                var direction = getDirection(this.option);\n                this.components.push({\n                    id: 'global-custom',\n                    component: component,\n                    layer: layer,\n                    direction: direction,\n                    type: COMPONENT_TYPE.LEGEND,\n                    extra: undefined,\n                });\n            }\n        }\n        else {\n            // 遍历处理每一个创建逻辑\n            this.loopLegends(doEachLegend);\n        }\n    };\n    /**\n     * layout legend\n     * 计算出 legend 的 direction 位置 x, y\n     */\n    Legend.prototype.layout = function () {\n        var _this = this;\n        this.layoutBBox = this.view.viewBBox;\n        each(this.components, function (co) {\n            var component = co.component, direction = co.direction;\n            var layout = getLegendLayout(direction);\n            var maxSize = _this.getCategoryLegendSizeCfg(layout);\n            var maxWidth = component.get('maxWidth');\n            var maxHeight = component.get('maxHeight');\n            // 先更新 maxSize，更新 layoutBBox，以便计算正确的 x y\n            component.update({\n                maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),\n                maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0),\n            });\n            var bboxObject = component.getLayoutBBox(); // 这里只需要他的 width、height 信息做位置调整\n            var bbox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);\n            var _a = directionToPosition(_this.view.coordinateBBox, bbox, direction), x1 = _a[0], y1 = _a[1];\n            var _b = directionToPosition(_this.layoutBBox, bbox, direction), x2 = _b[0], y2 = _b[1];\n            var x = 0;\n            var y = 0;\n            // 因为 legend x y 要和 coordinateBBox 对齐，所以要做一个简单的判断\n            if (direction.startsWith('top') || direction.startsWith('bottom')) {\n                x = x1;\n                y = y2;\n            }\n            else {\n                x = x2;\n                y = y1;\n            }\n            // 更新位置\n            component.update({\n                x: x,\n                y: y,\n            });\n            _this.layoutBBox = _this.layoutBBox.cut(bbox, direction);\n        });\n    };\n    /**\n     * legend 的更新逻辑\n     */\n    Legend.prototype.update = function () {\n        var _this = this;\n        this.option = this.view.getOptions().legends;\n        // 已经处理过的 legend\n        var updated = {};\n        var eachLegend = function (geometry, attr, scale) {\n            var id = _this.getId(scale.field);\n            var existCo = _this.getComponentById(id);\n            // 存在则 update\n            if (existCo) {\n                var cfg = void 0;\n                var legendOption = getLegendOption(_this.option, scale.field);\n                // if the legend option is not false, means legend should be created.\n                if (legendOption !== false) {\n                    if (get(legendOption, 'custom')) {\n                        cfg = _this.getCategoryCfg(geometry, attr, scale, legendOption, true);\n                    }\n                    else {\n                        if (scale.isLinear) {\n                            // linear field, create continuous legend\n                            cfg = _this.getContinuousCfg(geometry, attr, scale, legendOption);\n                        }\n                        else if (scale.isCategory) {\n                            // category field, create category legend\n                            cfg = _this.getCategoryCfg(geometry, attr, scale, legendOption);\n                        }\n                    }\n                }\n                // 如果 cfg 为空，则不在 updated 标记，那么会在后面逻辑中删除\n                if (cfg) {\n                    // omit 掉一些属性，比如 container 等\n                    omit(cfg, ['container']);\n                    existCo.direction = getDirection(legendOption);\n                    existCo.component.update(cfg);\n                    // 标记为新的\n                    updated[id] = true;\n                }\n            }\n            else {\n                // 不存在则 create\n                var legend = _this.createFieldLegend(geometry, attr, scale);\n                if (legend) {\n                    legend.component.init();\n                    _this.components.push(legend);\n                    // 标记为新的\n                    updated[id] = true;\n                }\n            }\n        };\n        // 全局自定义图例\n        if (get(this.option, 'custom')) {\n            var id = 'global-custom';\n            var existCo = this.getComponentById(id);\n            if (existCo) {\n                var customCfg = this.getCategoryCfg(undefined, undefined, undefined, this.option, true);\n                omit(customCfg, ['container']);\n                existCo.component.update(customCfg);\n                updated[id] = true;\n            }\n            else {\n                var component = this.createCustomLegend(undefined, undefined, undefined, this.option);\n                if (component) {\n                    component.init();\n                    var layer = LAYER.FORE;\n                    var direction = getDirection(this.option);\n                    this.components.push({\n                        id: id,\n                        component: component,\n                        layer: layer,\n                        direction: direction,\n                        type: COMPONENT_TYPE.LEGEND,\n                        extra: undefined,\n                    });\n                    // 标记为更新\n                    updated[id] = true;\n                }\n            }\n        }\n        else {\n            // 遍历处理每一个创建逻辑\n            this.loopLegends(eachLegend);\n        }\n        // 处理完成之后，销毁删除的\n        // 不在处理中的\n        var components = [];\n        each(this.getComponents(), function (co) {\n            if (updated[co.id]) {\n                components.push(co);\n            }\n            else {\n                co.component.destroy();\n            }\n        });\n        // 更新当前已有的 components\n        this.components = components;\n    };\n    Legend.prototype.clear = function () {\n        _super.prototype.clear.call(this);\n        this.container.clear();\n    };\n    Legend.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        this.container.remove(true);\n    };\n    /**\n     * 递归获取所有的 Geometry\n     */\n    Legend.prototype.getGeometries = function (view, geometries) {\n        var _this = this;\n        if (geometries === void 0) { geometries = []; }\n        // 首先获得当前 view 的 Geometries\n        geometries.push.apply(geometries, view.geometries);\n        // 然后递归\n        each(view.views, function (v) {\n            return _this.getGeometries(v, geometries);\n        });\n        return geometries;\n    };\n    /**\n     * 遍历 Geometry，处理 legend 逻辑\n     * @param doEach 每个 loop 中的处理方法\n     */\n    Legend.prototype.loopLegends = function (doEach) {\n        var isRootView = this.view.getRootView() === this.view;\n        // 非根 view，不处理 legend\n        if (!isRootView) {\n            return;\n        }\n        // 递归 view 中所有的 Geometry，进行创建 legend\n        var geometries = this.getGeometries(this.view);\n        var looped = {}; // 防止一个字段创建两个 legend\n        each(geometries, function (geometry) {\n            var attributes = geometry.getGroupAttributes();\n            each(attributes, function (attr) {\n                var scale = attr.getScale(attr.type);\n                // 如果在视觉通道上映射常量值，如 size(2) shape('circle') 不创建 legend\n                if (!scale || scale.type === 'identity' || looped[scale.field]) {\n                    return;\n                }\n                doEach(geometry, attr, scale);\n                looped[scale.field] = true;\n            });\n        });\n    };\n    /**\n     * 创建一个 legend\n     * @param geometry\n     * @param attr\n     * @param scale\n     */\n    Legend.prototype.createFieldLegend = function (geometry, attr, scale) {\n        var component;\n        var legendOption = getLegendOption(this.option, scale.field);\n        var layer = LAYER.FORE;\n        var direction = getDirection(legendOption);\n        // if the legend option is not false, means legend should be created.\n        if (legendOption !== false) {\n            if (get(legendOption, 'custom')) {\n                component = this.createCustomLegend(geometry, attr, scale, legendOption);\n            }\n            else {\n                if (scale.isLinear) {\n                    // linear field, create continuous legend\n                    component = this.createContinuousLegend(geometry, attr, scale, legendOption);\n                }\n                else if (scale.isCategory) {\n                    // category field, create category legend\n                    component = this.createCategoryLegend(geometry, attr, scale, legendOption);\n                }\n            }\n        }\n        if (component) {\n            component.set('field', scale.field);\n            return {\n                id: this.getId(scale.field),\n                component: component,\n                layer: layer,\n                direction: direction,\n                type: COMPONENT_TYPE.LEGEND,\n                extra: { scale: scale },\n            };\n        }\n    };\n    /**\n     * 自定义图例使用 category 图例去渲染\n     * @param geometry\n     * @param attr\n     * @param scale\n     * @param legendOption\n     */\n    Legend.prototype.createCustomLegend = function (geometry, attr, scale, legendOption) {\n        // 直接使用 分类图例渲染\n        var cfg = this.getCategoryCfg(geometry, attr, scale, legendOption, true);\n        return new CategoryLegend(cfg);\n    };\n    /**\n     * 创建连续图例\n     * @param geometry\n     * @param attr\n     * @param scale\n     * @param legendOption\n     */\n    Legend.prototype.createContinuousLegend = function (geometry, attr, scale, legendOption) {\n        var cfg = this.getContinuousCfg(geometry, attr, scale, legendOption);\n        return new ContinuousLegend(cfg);\n    };\n    /**\n     * 创建分类图例\n     * @param geometry\n     * @param attr\n     * @param scale\n     * @param legendOption\n     */\n    Legend.prototype.createCategoryLegend = function (geometry, attr, scale, legendOption) {\n        var cfg = this.getCategoryCfg(geometry, attr, scale, legendOption);\n        return new CategoryLegend(cfg);\n    };\n    /**\n     * 获得连续图例的配置\n     * @param geometry\n     * @param attr\n     * @param scale\n     * @param legendOption\n     */\n    Legend.prototype.getContinuousCfg = function (geometry, attr, scale, legendOption) {\n        var ticks = scale.getTicks();\n        var containMin = find(ticks, function (tick) { return tick.value === 0; });\n        var containMax = find(ticks, function (tick) { return tick.value === 1; });\n        var items = map(ticks, function (tick) {\n            var value = tick.value, tickValue = tick.tickValue;\n            var attrValue = attr.mapping(scale.invert(value)).join('');\n            return {\n                value: tickValue,\n                attrValue: attrValue,\n                color: attrValue,\n                scaleValue: value,\n            };\n        });\n        if (!containMin) {\n            items.push({\n                value: scale.min,\n                attrValue: attr.mapping(0).join(''),\n                color: attr.mapping(0).join(''),\n                scaleValue: 0,\n            });\n        }\n        if (!containMax) {\n            items.push({\n                value: scale.max,\n                attrValue: attr.mapping(1).join(''),\n                color: attr.mapping(1).join(''),\n                scaleValue: 1,\n            });\n        }\n        // 排序\n        items.sort(function (a, b) { return a.value - b.value; });\n        // 跟 attr 相关的配置\n        // size color 区别的配置\n        var attrLegendCfg = {\n            min: head(items).value,\n            max: last(items).value,\n            colors: [],\n            rail: {\n                type: attr.type,\n            },\n            track: {},\n        };\n        if (attr.type === 'size') {\n            attrLegendCfg = __assign(__assign({}, attrLegendCfg), { track: {\n                    style: {\n                        // size 的选中前景色，对于 color，则直接使用 color 标识\n                        // @ts-ignore\n                        fill: attr.type === 'size' ? this.view.getTheme().defaultColor : undefined,\n                    },\n                } });\n        }\n        if (attr.type === 'color') {\n            attrLegendCfg = __assign(__assign({}, attrLegendCfg), { colors: map(items, function (item) { return item.attrValue; }) });\n        }\n        var container = this.container;\n        // if position is not set, use top as default\n        var direction = getDirection(legendOption);\n        var layout = getLegendLayout(direction);\n        var title = get(legendOption, 'title');\n        if (title) {\n            title = deepMix({\n                text: getName(scale),\n            }, title);\n        }\n        // 基础配置，从当前数据中读到的配置\n        var baseCfg = __assign(__assign({ container: container,\n            layout: layout }, attrLegendCfg), { title: title });\n        // @ts-ignore\n        return this.mergeLegendCfg(baseCfg, legendOption, 'continuous');\n    };\n    /**\n     * 获取分类图例的配置项\n     * @param geometry\n     * @param attr\n     * @param scale\n     * @param custom\n     * @param legendOption\n     */\n    Legend.prototype.getCategoryCfg = function (geometry, attr, scale, legendOption, custom) {\n        var container = this.container;\n        // if position is not set, use top as default\n        var direction = get(legendOption, 'position', DIRECTION.BOTTOM);\n        // the default marker style\n        var themeMarker = get(this.view.getTheme(), ['components', 'legend', direction, 'marker']);\n        var userMarker = get(legendOption, 'marker');\n        var layout = getLegendLayout(direction);\n        var items = custom ?\n            getCustomLegendItems(themeMarker, userMarker, legendOption.items) :\n            getLegendItems(this.view, geometry, attr, themeMarker, userMarker);\n        var title = get(legendOption, 'title');\n        if (title) {\n            title = deepMix({\n                text: scale ? getName(scale) : '',\n            }, title);\n        }\n        var baseCfg = __assign({ container: container,\n            layout: layout,\n            items: items,\n            title: title }, this.getCategoryLegendSizeCfg(layout));\n        var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction);\n        if (categoryCfg.reversed) {\n            // 图例项需要逆序\n            categoryCfg.items.reverse();\n        }\n        return categoryCfg;\n    };\n    /**\n     * get legend config, use option > suggestion > theme\n     * @param baseCfg\n     * @param legendOption\n     * @param direction\n     */\n    Legend.prototype.mergeLegendCfg = function (baseCfg, legendOption, direction) {\n        var themeObject = get(this.view.getTheme(), ['components', 'legend', direction], {});\n        return deepMix({}, themeObject, baseCfg, {\n            animateOption: DEFAULT_ANIMATE_CFG,\n        }, legendOption);\n    };\n    /**\n     * 生成 id\n     * @param key\n     */\n    Legend.prototype.getId = function (key) {\n        return this.name + \"-\" + key;\n    };\n    /**\n     * 根据 id 来获取组件\n     * @param id\n     */\n    Legend.prototype.getComponentById = function (id) {\n        return find(this.components, function (co) { return co.id === id; });\n    };\n    Legend.prototype.getCategoryLegendSizeCfg = function (layout) {\n        var _a = this.view.viewBBox, vw = _a.width, vh = _a.height;\n        var _b = this.view.coordinateBBox, cw = _b.width, ch = _b.height;\n        return layout === 'vertical'\n            ? {\n                maxWidth: vw * COMPONENT_MAX_VIEW_PERCENTAGE,\n                maxHeight: ch,\n            }\n            : {\n                maxWidth: cw,\n                maxHeight: vh * COMPONENT_MAX_VIEW_PERCENTAGE,\n            };\n    };\n    return Legend;\n}(Controller));\nexport default Legend;\n//# sourceMappingURL=legend.js.map"]},"metadata":{},"sourceType":"module"}