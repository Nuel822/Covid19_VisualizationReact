{"ast":null,"code":"import { transform } from '@antv/matrix-util';\n/**\n * @ignore\n * 沿着 x 方向放大的动画\n * @param shape\n * @param animateCfg\n * @param shapeModel\n */\n\nexport function scaleInX(shape, animateCfg, cfg) {\n  var box = shape.getBBox();\n  var mappingData = shape.get('origin').mappingData;\n  var points = mappingData.points; // x 数值如果为负值，那么应该从右往左生长\n\n  var x = points[0].y - points[1].y > 0 ? box.maxX : box.minX;\n  var y = (box.minY + box.maxY) / 2;\n  shape.applyToMatrix([x, y, 1]);\n  var matrix = transform(shape.getMatrix(), [['t', -x, -y], ['s', 0.01, 1], ['t', x, y]]);\n  shape.setMatrix(matrix);\n  shape.animate({\n    matrix: transform(shape.getMatrix(), [['t', -x, -y], ['s', 100, 1], ['t', x, y]])\n  }, animateCfg);\n}\n/**\n * @ignore\n * 沿着 y 方向放大的动画\n * @param shape\n * @param animateCfg\n * @param shapeModel\n */\n\nexport function scaleInY(shape, animateCfg, cfg) {\n  var box = shape.getBBox();\n  var mappingData = shape.get('origin').mappingData;\n  var x = (box.minX + box.maxX) / 2;\n  var points = mappingData.points; // 数值如果为负值，那么应该从上往下生长，通过 shape 的关键点进行判断\n\n  var y = points[0].y - points[1].y <= 0 ? box.maxY : box.minY;\n  shape.applyToMatrix([x, y, 1]);\n  var matrix = transform(shape.getMatrix(), [['t', -x, -y], ['s', 1, 0.01], ['t', x, y]]);\n  shape.setMatrix(matrix);\n  shape.animate({\n    matrix: transform(shape.getMatrix(), [['t', -x, -y], ['s', 1, 100], ['t', x, y]])\n  }, animateCfg);\n}","map":{"version":3,"sources":["../../../src/animate/animation/scale-in.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { transform } from '@antv/matrix-util';\n/**\n * @ignore\n * 沿着 x 方向放大的动画\n * @param shape\n * @param animateCfg\n * @param shapeModel\n */\nexport function scaleInX(shape, animateCfg, cfg) {\n    var box = shape.getBBox();\n    var mappingData = shape.get('origin').mappingData;\n    var points = mappingData.points;\n    // x 数值如果为负值，那么应该从右往左生长\n    var x = points[0].y - points[1].y > 0 ? box.maxX : box.minX;\n    var y = (box.minY + box.maxY) / 2;\n    shape.applyToMatrix([x, y, 1]);\n    var matrix = transform(shape.getMatrix(), [\n        ['t', -x, -y],\n        ['s', 0.01, 1],\n        ['t', x, y],\n    ]);\n    shape.setMatrix(matrix);\n    shape.animate({\n        matrix: transform(shape.getMatrix(), [\n            ['t', -x, -y],\n            ['s', 100, 1],\n            ['t', x, y],\n        ]),\n    }, animateCfg);\n}\n/**\n * @ignore\n * 沿着 y 方向放大的动画\n * @param shape\n * @param animateCfg\n * @param shapeModel\n */\nexport function scaleInY(shape, animateCfg, cfg) {\n    var box = shape.getBBox();\n    var mappingData = shape.get('origin').mappingData;\n    var x = (box.minX + box.maxX) / 2;\n    var points = mappingData.points;\n    // 数值如果为负值，那么应该从上往下生长，通过 shape 的关键点进行判断\n    var y = points[0].y - points[1].y <= 0 ? box.maxY : box.minY;\n    shape.applyToMatrix([x, y, 1]);\n    var matrix = transform(shape.getMatrix(), [\n        ['t', -x, -y],\n        ['s', 1, 0.01],\n        ['t', x, y],\n    ]);\n    shape.setMatrix(matrix);\n    shape.animate({\n        matrix: transform(shape.getMatrix(), [\n            ['t', -x, -y],\n            ['s', 1, 100],\n            ['t', x, y],\n        ]),\n    }, animateCfg);\n}\n//# sourceMappingURL=scale-in.js.map"]},"metadata":{},"sourceType":"module"}