{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { getAdjust as getAdjustClass } from '@antv/adjust';\nimport { getAttribute as getAttributeClass } from '@antv/attr';\nimport { clone, deepMix, each, flatten, get, isArray, isEmpty, isEqual, isFunction, isNil, isNumber, isObject, isPlainObject, isString, map, set, uniq } from '@antv/util';\nimport { doGroupAppearAnimate } from '../animate';\nimport Base from '../base';\nimport { FIELD_ORIGIN, GROUP_ATTRS } from '../constant';\nimport Element from './element';\nimport { getGeometryLabel } from './label';\nimport { getShapeFactory } from './shape/base';\nimport { group } from './util/group-data';\nimport { isModelChange } from './util/is-model-change';\nimport { parseFields } from './util/parse-fields'; // 根据 elementId 查找对应的 label，因为有可能一个 element 对应多个 labels，所以在给 labels 打标识时做了处理\n// 打标规则详见 ./label/base.ts#L263\n\nfunction filterLabelsById(id, labelsMap) {\n  var labels = [];\n  each(labelsMap, function (label, labelId) {\n    var elementId = labelId.split(' ')[0];\n\n    if (elementId === id) {\n      labels.push(label);\n    }\n  });\n  return labels;\n}\n/**\n * Geometry 几何标记基类，主要负责数据到图形属性的映射以及绘制逻辑。\n */\n\n\nvar Geometry =\n/** @class */\nfunction (_super) {\n  __extends(Geometry, _super);\n  /**\n   * 创建 Geometry 实例。\n   * @param cfg\n   */\n\n\n  function Geometry(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    /** Geometry 几何标记类型。 */\n\n\n    _this.type = 'base'; // 内部产生的属性\n\n    /** Attribute map  */\n\n    _this.attributes = {};\n    /** Element map */\n\n    _this.elements = [];\n    /** animate 配置项 */\n\n    _this.animateOption = true;\n    /** 使用 key-value 结构存储 Element，key 为每个 Element 实例对应的唯一 ID */\n\n    _this.elementsMap = {};\n    /** 图形属性映射配置 */\n\n    _this.attributeOption = {};\n    /** 存储上一次渲染时的 element 映射表，用于更新逻辑 */\n\n    _this.lastElementsMap = {};\n    /** 是否生成多个点来绘制图形。 */\n\n    _this.generatePoints = false;\n    /** 存储发生图形属性映射前的数据 */\n\n    _this.beforeMappingData = null;\n    _this.adjusts = {};\n    _this.idFields = [];\n    var container = cfg.container,\n        labelsContainer = cfg.labelsContainer,\n        coordinate = cfg.coordinate,\n        data = cfg.data,\n        _a = cfg.sortable,\n        sortable = _a === void 0 ? false : _a,\n        _b = cfg.visible,\n        visible = _b === void 0 ? true : _b,\n        theme = cfg.theme,\n        _c = cfg.scales,\n        scales = _c === void 0 ? {} : _c,\n        _d = cfg.scaleDefs,\n        scaleDefs = _d === void 0 ? {} : _d;\n    _this.container = container;\n    _this.labelsContainer = labelsContainer;\n    _this.coordinate = coordinate;\n    _this.data = data;\n    _this.sortable = sortable;\n    _this.visible = visible;\n    _this.userTheme = theme;\n    _this.scales = scales;\n    _this.scaleDefs = scaleDefs;\n    return _this;\n  }\n  /**\n   * 配置 position 通道映射规则。\n   *\n   * @example\n   * ```typescript\n   * // 数据结构: [{ x: 'A', y: 10, color: 'red' }]\n   * geometry.position('x*y');\n   * geometry.position([ 'x', 'y' ]);\n   * geometry.position({\n   *   fields: [ 'x', 'y' ],\n   * });\n   * ```\n   *\n   * @param cfg 映射规则\n   * @returns\n   */\n\n\n  Geometry.prototype.position = function (cfg) {\n    var positionCfg = cfg;\n\n    if (!isPlainObject(cfg)) {\n      // 字符串字段或者数组字段\n      positionCfg = {\n        fields: parseFields(cfg)\n      };\n    }\n\n    var fields = get(positionCfg, 'fields');\n\n    if (fields.length === 1) {\n      // 默认填充一维 1*xx\n      fields.unshift('1');\n      set(positionCfg, 'fields', fields);\n    }\n\n    set(this.attributeOption, 'position', positionCfg);\n    return this;\n  };\n\n  Geometry.prototype.color = function (field, cfg) {\n    this.createAttrOption('color', field, cfg);\n    return this;\n  };\n\n  Geometry.prototype.shape = function (field, cfg) {\n    this.createAttrOption('shape', field, cfg);\n    return this;\n  };\n\n  Geometry.prototype.size = function (field, cfg) {\n    this.createAttrOption('size', field, cfg);\n    return this;\n  };\n  /**\n   * 设置数据调整方式。G2 目前内置了四种类型：\n   * 1. dodge\n   * 2. stack\n   * 3. symmetric\n   * 4. jitter\n   *\n   *\n   * **Tip**\n   * + 对于 'dodge' 类型，可以额外进行如下属性的配置:\n   * ```typescript\n   * geometry.adjust('dodge', {\n   *   marginRatio: 0, // 取 0 到 1 范围的值（相对于每个柱子宽度），用于控制一个分组中柱子之间的间距\n   *   dodgeBy: 'x', // 该属性只对 'dodge' 类型生效，声明以哪个数据字段为分组依据\n   * });\n   * ```\n   *\n   * + 对于 'stack' 类型，可以额外进行如下属性的配置:\n   * ```typescript\n   * geometry.adjust('stack', {\n   *   reverseOrder: false, // 用于控制是否对数据进行反序操作\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * geometry.adjust('stack');\n   *\n   * geometry.adjust({\n   *   type: 'stack',\n   *   reverseOrder: false,\n   * });\n   *\n   * // 组合使用 adjust\n   * geometry.adjust([ 'stack', 'dodge' ]);\n   *\n   * geometry.adjust([\n   *   { type: 'stack' },\n   *   { type: 'dodge', dodgeBy: 'x' },\n   * ]);\n   * ```\n   *\n   * @param adjustCfg 数据调整配置\n   * @returns\n   */\n\n\n  Geometry.prototype.adjust = function (adjustCfg) {\n    var adjusts = adjustCfg;\n\n    if (isString(adjustCfg) || isPlainObject(adjustCfg)) {\n      adjusts = [adjustCfg];\n    }\n\n    each(adjusts, function (adjust, index) {\n      if (!isObject(adjust)) {\n        adjusts[index] = {\n          type: adjust\n        };\n      }\n    });\n    this.adjustOption = adjusts;\n    return this;\n  };\n\n  Geometry.prototype.style = function (field, styleFunc) {\n    if (isString(field)) {\n      var fields = parseFields(field);\n      this.styleOption = {\n        fields: fields,\n        callback: styleFunc\n      };\n    } else {\n      var _a = field,\n          fields = _a.fields,\n          callback = _a.callback,\n          cfg = _a.cfg;\n\n      if (fields || callback || cfg) {\n        this.styleOption = field;\n      } else {\n        this.styleOption = {\n          cfg: field\n        };\n      }\n    }\n\n    return this;\n  };\n\n  Geometry.prototype.tooltip = function (field, cfg) {\n    if (isString(field)) {\n      var fields = parseFields(field);\n      this.tooltipOption = {\n        fields: fields,\n        callback: cfg\n      };\n    } else {\n      this.tooltipOption = field;\n    }\n\n    return this;\n  };\n  /**\n   * Geometry 动画配置。\n   *\n   * + `animate(false)` 关闭动画\n   * + `animate(true)` 开启动画，默认开启。\n   *\n   * 我们将动画分为四个场景：\n   * 1. appear: 图表第一次加载时的入场动画；\n   * 2. enter: 图表绘制完成，发生更新后，产生的新图形的进场动画；\n   * 3. update: 图表绘制完成，数据发生变更后，有状态变更的图形的更新动画；\n   * 4. leave: 图表绘制完成，数据发生变更后，被销毁图形的销毁动画。\n   *\n   * @example\n   * ```typescript\n   * animate({\n   *   enter: {\n   *     duration: 1000, // enter 动画执行时间\n   *   },\n   *   leave: false, // 关闭 leave 销毁动画\n   * });\n   * ```\n   *\n   * @param cfg 动画配置\n   * @returns\n   */\n\n\n  Geometry.prototype.animate = function (cfg) {\n    this.animateOption = cfg;\n    return this;\n  };\n\n  Geometry.prototype.label = function (field, secondParam, thirdParam) {\n    if (isString(field)) {\n      var labelOption = {};\n      var fields = parseFields(field);\n      labelOption.fields = fields;\n\n      if (isFunction(secondParam)) {\n        labelOption.callback = secondParam;\n      } else if (isPlainObject(secondParam)) {\n        labelOption.cfg = secondParam;\n      }\n\n      if (thirdParam) {\n        labelOption.cfg = thirdParam;\n      }\n\n      this.labelOption = labelOption;\n    } else {\n      this.labelOption = field;\n    }\n\n    return this;\n  };\n  /**\n   * 设置状态对应的样式。\n   *\n   * @example\n   * ```ts\n   * chart.interval().state({\n   *   selected: {\n   *     animate: { duration: 100, easing: 'easeLinear' },\n   *     style: {\n   *       lineWidth: 2,\n   *       stroke: '#000',\n   *     },\n   *   },\n   * });\n   * ```\n   *\n   * 如果图形 shape 是由多个 shape 组成，即为一个 G.Group 对象，那么针对 group 中的每个 shape，我们需要使用下列方式进行状态样式设置：\n   * 如果我们为 group 中的每个 shape 设置了 'name' 属性(shape.set('name', 'xx'))，则以 'name' 作为 key，否则默认以索引值（即 shape 的 添加顺序）为 key。\n   *\n   * ```ts\n   * chart.interval().shape('groupShape').state({\n   *   selected: {\n   *     style: {\n   *       0: { lineWidth: 2 },\n   *       1: { fillOpacity: 1 },\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * @param cfg 状态样式\n   */\n\n\n  Geometry.prototype.state = function (cfg) {\n    this.stateOption = cfg;\n    return this;\n  };\n  /**\n   * 初始化 Geomtry 实例：\n   * 创建 [[Attribute]] and [[Scale]] 实例，进行数据处理，包括分组、数值化以及数据调整。\n   */\n\n\n  Geometry.prototype.init = function (cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.setCfg(cfg);\n    this.initAttributes(); // 创建图形属性\n    // 数据加工：分组 -> 数字化 -> adjust\n\n    this.processData(this.data); // 调整 scale\n\n    this.adjustScale();\n  };\n  /**\n   * Geometry 更新。\n   * @param [cfg] 更新的配置\n   */\n\n\n  Geometry.prototype.update = function (cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    var data = cfg.data,\n        isDataChanged = cfg.isDataChanged;\n\n    var _a = this,\n        attributeOption = _a.attributeOption,\n        lastAttributeOption = _a.lastAttributeOption;\n\n    if (!isEqual(attributeOption, lastAttributeOption)) {\n      // 映射发生改变，则重新创建图形属性\n      this.init(cfg);\n    } else if (data && (isDataChanged || !isEqual(data, this.data))) {\n      // 数据发生变化\n      this.setCfg(cfg);\n      this.processData(data); // 数据加工：分组 -> 数字化 -> adjust\n    } else {\n      // 有可能 coordinate 变化\n      this.setCfg(cfg);\n    } // 调整 scale\n\n\n    this.adjustScale();\n  };\n  /**\n   * 将原始数据映射至图形空间，同时创建图形对象。\n   */\n\n\n  Geometry.prototype.paint = function (isUpdate) {\n    var _this = this;\n\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n\n    this.defaultSize = undefined;\n    this.elements = [];\n    this.elementsMap = {};\n    var offscreenGroup = this.getOffscreenGroup();\n    offscreenGroup.clear();\n    var beforeMappingData = this.beforeMappingData;\n    var dataArray = this.beforeMapping(beforeMappingData);\n    var mappingArray = [];\n    dataArray.forEach(function (eachGroup, index) {\n      var mappingData = _this.mapping(eachGroup);\n\n      mappingArray.push(mappingData);\n\n      _this.createElements(mappingData, index, isUpdate);\n    });\n\n    if (this.canDoGroupAnimation(isUpdate)) {\n      // 如果用户没有配置 appear.animation，就默认走整体动画\n      var container = this.container;\n      var type = this.type;\n      var coordinate = this.coordinate;\n      var animateCfg = get(this.animateOption, 'appear');\n      var yScale = this.getYScale();\n      var yMinPoint = coordinate.convert({\n        x: 0,\n        y: yScale.scale(this.getYMinValue())\n      });\n      doGroupAppearAnimate(container, animateCfg, type, coordinate, yMinPoint);\n    } // 添加 label\n\n\n    if (this.labelOption) {\n      this.renderLabels(flatten(mappingArray), isUpdate);\n    }\n\n    this.afterMapping(mappingArray); // 销毁被删除的 elements\n\n    each(this.lastElementsMap, function (deletedElement) {\n      // 更新动画配置，用户有可能在更新之前有对动画进行配置操作\n      deletedElement.animate = _this.animateOption;\n      deletedElement.destroy();\n    });\n    this.lastElementsMap = this.elementsMap; // 缓存，用于更新\n\n    this.lastAttributeOption = __assign({}, this.attributeOption);\n\n    if (this.visible === false) {\n      // 用户在初始化的时候声明 visible: false\n      this.changeVisible(false);\n    }\n  };\n  /**\n   * 清空当前 Geometry，配置项仍保留，但是内部创建的对象全部清空。\n   * @override\n   */\n\n\n  Geometry.prototype.clear = function () {\n    var _a = this,\n        container = _a.container,\n        geometryLabel = _a.geometryLabel;\n\n    if (container) {\n      container.clear();\n    }\n\n    if (geometryLabel) {\n      geometryLabel.clear();\n    } // 属性恢复至出厂状态\n\n\n    this.attributes = {};\n    this.scales = {};\n    this.elementsMap = {};\n    this.lastElementsMap = {};\n    this.elements = [];\n    this.dataArray = null;\n    this.beforeMappingData = null;\n    this.lastAttributeOption = undefined;\n    this.defaultSize = undefined;\n    this.idFields = [];\n  };\n  /**\n   * 销毁 Geometry 实例。\n   */\n\n\n  Geometry.prototype.destroy = function () {\n    this.clear();\n    var container = this.container;\n    container.remove(true);\n\n    if (this.offscreenGroup) {\n      this.offscreenGroup.remove(true);\n      this.offscreenGroup = null;\n    }\n\n    if (this.geometryLabel) {\n      this.geometryLabel.destroy();\n      this.geometryLabel = null;\n    }\n\n    this.theme = undefined;\n\n    _super.prototype.destroy.call(this);\n  };\n  /**\n   * 获取决定分组的图形属性对应的 scale 实例。\n   * @returns\n   */\n\n\n  Geometry.prototype.getGroupScales = function () {\n    var scales = [];\n    var attributes = this.attributes;\n    each(attributes, function (attr) {\n      if (GROUP_ATTRS.includes(attr.type)) {\n        var attrScales = attr.scales;\n        each(attrScales, function (scale) {\n          if (scale.isCategory && !scales.includes(scale)) {\n            scales.push(scale);\n          }\n        });\n      }\n    });\n    return scales;\n  };\n  /**\n   * 根据名字获取图形属性实例。\n   */\n\n\n  Geometry.prototype.getAttribute = function (name) {\n    return this.attributes[name];\n  };\n  /** 获取 x 轴对应的 scale 实例。 */\n\n\n  Geometry.prototype.getXScale = function () {\n    return this.getAttribute('position').scales[0];\n  };\n  /** 获取 y 轴对应的 scale 实例。 */\n\n\n  Geometry.prototype.getYScale = function () {\n    return this.getAttribute('position').scales[1];\n  };\n  /**\n   * 获取决定分组的图形属性实例。\n   */\n\n\n  Geometry.prototype.getGroupAttributes = function () {\n    var rst = [];\n    each(this.attributes, function (attr) {\n      if (GROUP_ATTRS.includes(attr.type)) {\n        rst.push(attr);\n      }\n    });\n    return rst;\n  };\n  /** 获取图形属性默认的映射值。 */\n\n\n  Geometry.prototype.getDefaultValue = function (attrName) {\n    var value;\n    var attr = this.getAttribute(attrName);\n\n    if (attr && isEmpty(attr.scales)) {\n      // 获取映射至常量的值\n      value = attr.values[0];\n    }\n\n    return value;\n  };\n  /**\n   * 获取该数据发生图形映射后对应的 Attribute 图形空间数据。\n   * @param attr Attribute 图形属性实例。\n   * @param obj 需要进行映射的原始数据。\n   * @returns\n   */\n\n\n  Geometry.prototype.getAttributeValues = function (attr, obj) {\n    var scales = attr.scales;\n    var params = map(scales, function (scale) {\n      var field = scale.field;\n\n      if (scale.type === 'identity') {\n        return scale.values[0];\n      }\n\n      if (scale.isCategory) {\n        return obj[field]; // 数据有可能发生过 adjust\n      }\n\n      return obj[field];\n    });\n    return attr.mapping.apply(attr, params);\n  };\n\n  Geometry.prototype.getAdjust = function (adjustType) {\n    return this.adjusts[adjustType];\n  };\n  /**\n   * 获取 shape 对应的 marker 样式。\n   * @param shapeName shape 具体名字\n   * @param cfg marker 信息\n   * @returns\n   */\n\n\n  Geometry.prototype.getShapeMarker = function (shapeName, cfg) {\n    var shapeFactory = this.getShapeFactory();\n    return shapeFactory.getMarker(shapeName, cfg);\n  };\n  /**\n   * 根据一定的规则查找 Geometry 的 Elements。\n   *\n   * ```typescript\n   * getElementsBy((element) => {\n   *   const data = element.getData();\n   *\n   *   return data.a === 'a';\n   * });\n   * ```\n   *\n   * @param condition 定义查找规则的回调函数。\n   * @returns\n   */\n\n\n  Geometry.prototype.getElementsBy = function (condition) {\n    return this.elements.filter(function (element) {\n      return condition(element);\n    });\n  };\n  /**\n   * 获取数据对应的唯一 id。\n   * @param data Element 对应的绘制数据\n   * @returns\n   */\n\n\n  Geometry.prototype.getElementId = function (data) {\n    data = isArray(data) ? data[0] : data;\n    var originData = data[FIELD_ORIGIN]; // 如果用户声明了使用哪些字段作为 id 值\n\n    if (this.idFields.length) {\n      var elementId = originData[this.idFields[0]];\n\n      for (var index = 1; index < this.idFields.length; index++) {\n        elementId += '-' + originData[this.idFields[index]];\n      }\n\n      return elementId;\n    }\n\n    var type = this.type;\n    var xScale = this.getXScale();\n    var yScale = this.getYScale();\n    var xField = xScale.field || 'x';\n    var yField = yScale.field || 'y';\n    var yVal = originData[yField];\n    var xVal;\n\n    if (xScale.type === 'identity') {\n      xVal = xScale.values[0];\n    } else {\n      xVal = originData[xField];\n    }\n\n    var id;\n\n    if (type === 'interval' || type === 'schema') {\n      id = xVal;\n    } else if (type === 'line' || type === 'area' || type === 'path') {\n      id = type;\n    } else {\n      id = xVal + \"-\" + yVal;\n    }\n\n    var groupScales = this.getGroupScales();\n\n    if (!isEmpty(groupScales)) {\n      each(groupScales, function (groupScale) {\n        var field = groupScale.field;\n\n        if (groupScale.type !== 'identity') {\n          id = id + \"-\" + originData[field];\n        }\n      });\n    } // 用户在进行 dodge 类型的 adjust 调整的时候设置了 dodgeBy 属性\n\n\n    var dodgeAdjust = this.getAdjust('dodge');\n\n    if (dodgeAdjust) {\n      var dodgeBy = dodgeAdjust.dodgeBy;\n\n      if (dodgeBy) {\n        id = id + \"-\" + originData[dodgeBy];\n      }\n    }\n\n    if (this.getAdjust('jitter')) {\n      id = id + \"-\" + data.x + \"-\" + data.y;\n    }\n\n    return id;\n  };\n  /**\n   * 获取所有需要创建 scale 的字段名称。\n   */\n\n\n  Geometry.prototype.getScaleFields = function () {\n    var fields = [];\n\n    var _a = this,\n        attributeOption = _a.attributeOption,\n        labelOption = _a.labelOption,\n        tooltipOption = _a.tooltipOption;\n\n    each(attributeOption, function (eachOpt) {\n      // size(10)\n      fields = fields.concat(eachOpt.fields || eachOpt.values);\n    });\n    fields = fields.concat(get(labelOption, 'fields', []));\n    fields = fields.concat(get(tooltipOption, 'fields', []));\n    return uniq(fields);\n  };\n  /**\n   * 显示或者隐藏 geometry。\n   * @param visible\n   */\n\n\n  Geometry.prototype.changeVisible = function (visible) {\n    _super.prototype.changeVisible.call(this, visible);\n\n    this.elements.forEach(function (element) {\n      element.changeVisible(visible);\n    });\n\n    if (visible) {\n      if (this.container) {\n        this.container.show();\n      }\n\n      if (this.labelsContainer) {\n        this.labelsContainer.show();\n      }\n    } else {\n      if (this.container) {\n        this.container.hide();\n      }\n\n      if (this.labelsContainer) {\n        this.labelsContainer.hide();\n      }\n    }\n  };\n  /**\n   * 获取当前配置中的所有分组 & 分类的字段。\n   * @return fields string[]\n   */\n\n\n  Geometry.prototype.getGroupFields = function () {\n    var _this = this;\n\n    var fields = [];\n    each(GROUP_ATTRS, function (attributeName) {\n      var cfg = _this.attributeOption[attributeName];\n      fields.push.apply(fields, get(cfg, 'fields', []));\n    });\n    return uniq(fields);\n  };\n  /**\n   * 获得图形的 x y 字段。\n   */\n\n\n  Geometry.prototype.getXYFields = function () {\n    var _a = this.attributeOption.position.fields,\n        x = _a[0],\n        y = _a[1];\n    return [x, y];\n  };\n  /**\n   * 获取该 Geometry 下所有生成的 shapes。\n   * @returns shapes\n   */\n\n\n  Geometry.prototype.getShapes = function () {\n    return this.elements.map(function (element) {\n      return element.shape;\n    });\n  };\n  /**\n   * 获取虚拟 Group。\n   * @returns\n   */\n\n\n  Geometry.prototype.getOffscreenGroup = function () {\n    if (!this.offscreenGroup) {\n      var GroupCtor = this.container.getGroupBase(); // 获取分组的构造函数\n\n      this.offscreenGroup = new GroupCtor({});\n    }\n\n    return this.offscreenGroup;\n  };\n  /**\n   * 调整度量范围。主要针对发生层叠以及一些特殊需求的 Geometry，比如 Interval 下的柱状图 Y 轴默认从 0 开始。\n   */\n\n\n  Geometry.prototype.adjustScale = function () {\n    var yScale = this.getYScale(); // 如果数据发生过 stack adjust，需要调整下 yScale 的数据范围\n\n    if (this.getAdjust('stack') && yScale) {\n      this.updateStackRange(yScale, this.beforeMappingData);\n    }\n  };\n  /**\n   * 获取当前 Geometry 对应的 Shape 工厂实例。\n   */\n\n\n  Geometry.prototype.getShapeFactory = function () {\n    var shapeType = this.shapeType;\n\n    if (!getShapeFactory(shapeType)) {\n      return;\n    }\n\n    if (!this.shapeFactory) {\n      this.shapeFactory = clone(getShapeFactory(shapeType)); // 防止多个 view 共享一个 shapeFactory 实例，导致 coordinate 被篡改\n    } // 因为这里缓存了 shapeFactory，但是外部可能会变更 coordinate，导致无法重新设置到 shapeFactory 中\n\n\n    this.shapeFactory.coordinate = this.coordinate; // theme 原因同上\n\n    this.shapeFactory.theme = get(this.theme, ['geometries', shapeType], {});\n    return this.shapeFactory;\n  };\n  /**\n   * 获取每个 Shape 对应的关键点数据。\n   * @param obj 经过分组 -> 数字化 -> adjust 调整后的数据记录\n   * @returns\n   */\n\n\n  Geometry.prototype.createShapePointsCfg = function (obj) {\n    var xScale = this.getXScale();\n    var yScale = this.getYScale();\n    var x = this.normalizeValues(obj[xScale.field], xScale);\n    var y; // 存在没有 y 的情况\n\n    if (yScale) {\n      y = this.normalizeValues(obj[yScale.field], yScale);\n    } else {\n      y = obj.y ? obj.y : 0.1;\n    }\n\n    return {\n      x: x,\n      y: y,\n      y0: yScale ? yScale.scale(this.getYMinValue()) : undefined\n    };\n  };\n  /**\n   * 创建 Element 实例。\n   * @param mappingDatum Element 对应的绘制数据\n   * @param [isUpdate] 是否处于更新阶段\n   * @returns element 返回创建的 Element 实例\n   */\n\n\n  Geometry.prototype.createElement = function (mappingDatum, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n\n    var _a = this,\n        theme = _a.theme,\n        container = _a.container;\n\n    var shapeCfg = this.getDrawCfg(mappingDatum); // 获取绘制图形的配置信息\n\n    var shapeFactory = this.getShapeFactory();\n    var element = new Element({\n      theme: get(theme, ['geometries', this.shapeType], {}),\n      shapeFactory: shapeFactory,\n      container: container,\n      offscreenGroup: this.getOffscreenGroup()\n    });\n    element.geometry = this;\n    element.draw(shapeCfg, isUpdate); // 绘制\n\n    return element;\n  };\n  /**\n   * 获取每条数据对应的图形绘制数据。\n   * @param mappingDatum 映射后的数据\n   * @returns draw cfg\n   */\n\n\n  Geometry.prototype.getDrawCfg = function (mappingDatum) {\n    var originData = mappingDatum[FIELD_ORIGIN]; // 原始数据\n\n    var cfg = {\n      mappingData: mappingDatum,\n      data: originData,\n      x: mappingDatum.x,\n      y: mappingDatum.y,\n      color: mappingDatum.color,\n      size: mappingDatum.size,\n      isInCircle: this.coordinate.isPolar\n    };\n    var shapeName = mappingDatum.shape;\n\n    if (!shapeName && this.getShapeFactory()) {\n      shapeName = this.getShapeFactory().defaultShapeType;\n    }\n\n    cfg.shape = shapeName; // 获取默认样式\n\n    var theme = this.theme.geometries[this.shapeType];\n    cfg.defaultStyle = get(theme, [shapeName, 'default'], {}).style;\n    var styleOption = this.styleOption;\n\n    if (styleOption) {\n      cfg.style = this.getStyleCfg(styleOption, originData);\n    }\n\n    if (this.generatePoints) {\n      cfg.points = mappingDatum.points;\n      cfg.nextPoints = mappingDatum.nextPoints;\n    }\n\n    return cfg;\n  };\n  /**\n   * 创建所有的 Elements。\n   * @param mappingData\n   * @param [isUpdate]\n   * @returns elements\n   */\n\n\n  Geometry.prototype.createElements = function (mappingData, index, isUpdate) {\n    var _this = this;\n\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n\n    var _a = this,\n        lastElementsMap = _a.lastElementsMap,\n        elementsMap = _a.elementsMap,\n        elements = _a.elements;\n\n    each(mappingData, function (mappingDatum, subIndex) {\n      var id = _this.getElementId(mappingDatum);\n\n      if (elementsMap[id]) {\n        // 存在重复数据，则根据再根据 index 进行区分\n        id = id + \"-\" + index + \"-\" + subIndex;\n      }\n\n      var result = lastElementsMap[id];\n\n      if (!result) {\n        // 创建新的 element\n        result = _this.createElement(mappingDatum, isUpdate);\n      } else {\n        // element 已经创建\n        var currentShapeCfg = _this.getDrawCfg(mappingDatum);\n\n        var preShapeCfg = result.getModel();\n\n        if (isModelChange(currentShapeCfg, preShapeCfg)) {\n          // 通过绘制数据的变更来判断是否需要更新，因为用户有可能会修改图形属性映射\n          result.update(currentShapeCfg); // 更新对应的 element\n        }\n\n        delete lastElementsMap[id];\n      }\n\n      elements.push(result);\n      elementsMap[id] = result;\n    });\n    return elements;\n  };\n  /**\n   * 获取渲染的 label 类型。\n   */\n\n\n  Geometry.prototype.getLabelType = function () {\n    var _a = this,\n        labelOption = _a.labelOption,\n        coordinate = _a.coordinate,\n        type = _a.type;\n\n    var coordinateType = coordinate.type;\n    var labelType = get(labelOption, ['cfg', 'type']);\n\n    if (!labelType) {\n      // 用户未定义，则进行默认的逻辑\n      if (coordinateType === 'polar') {\n        // 极坐标下使用通用的极坐标文本\n        labelType = 'polar';\n      } else if (coordinateType === 'theta') {\n        // theta 坐标系下使用饼图文本\n        labelType = 'pie';\n      } else if (type === 'interval' || type === 'polygon') {\n        labelType = 'interval';\n      } else {\n        labelType = 'base';\n      }\n    }\n\n    return labelType;\n  };\n  /**\n   * 获取 Y 轴上的最小值。\n   */\n\n\n  Geometry.prototype.getYMinValue = function () {\n    var yScale = this.getYScale();\n    var min = yScale.min,\n        max = yScale.max;\n    var value;\n\n    if (min >= 0) {\n      value = min;\n    } else if (max <= 0) {\n      // 当值全位于负区间时，需要保证 ymin 在区域内，不可为 0\n      value = max;\n    } else {\n      value = 0;\n    }\n\n    return value;\n  }; // 创建图形属性相关的配置项\n\n\n  Geometry.prototype.createAttrOption = function (attrName, field, cfg) {\n    if (isNil(field) || isObject(field)) {\n      if (isObject(field) && isEqual(Object.keys(field), ['values'])) {\n        // shape({ values: [ 'funnel' ] })\n        set(this.attributeOption, attrName, {\n          fields: field.values\n        });\n      } else {\n        set(this.attributeOption, attrName, field);\n      }\n    } else {\n      var attrCfg = {};\n\n      if (isNumber(field)) {\n        // size(3)\n        attrCfg.values = [field];\n      } else {\n        attrCfg.fields = parseFields(field);\n      }\n\n      if (cfg) {\n        if (isFunction(cfg)) {\n          attrCfg.callback = cfg;\n        } else {\n          attrCfg.values = cfg;\n        }\n      }\n\n      set(this.attributeOption, attrName, attrCfg);\n    }\n  };\n\n  Geometry.prototype.initAttributes = function () {\n    var _this = this;\n\n    var _a = this,\n        attributes = _a.attributes,\n        attributeOption = _a.attributeOption,\n        theme = _a.theme,\n        shapeType = _a.shapeType; // 遍历每一个 attrOption，各自创建 Attribute 实例\n\n\n    each(attributeOption, function (option, attrType) {\n      if (!option) {\n        return;\n      }\n\n      var attrCfg = __assign({}, option);\n\n      var callback = attrCfg.callback,\n          values = attrCfg.values,\n          _a = attrCfg.fields,\n          fields = _a === void 0 ? [] : _a; // 获取每一个字段对应的 scale\n\n      var scales = map(fields, function (field) {\n        return _this.scales[field];\n      });\n      attrCfg.scales = scales;\n\n      if (attrType !== 'position' && scales.length === 1 && scales[0].type === 'identity') {\n        // 用户在图形通道上声明了常量字段 color('red'), size(5)\n        attrCfg.values = scales[0].values;\n      } else if (!callback && !values) {\n        // 用户没有指定任何规则，则使用默认的映射规则\n        if (attrType === 'size') {\n          attrCfg.values = theme.sizes;\n        } else if (attrType === 'shape') {\n          attrCfg.values = theme.shapes[shapeType] || [];\n        } else if (attrType === 'color') {\n          if (scales.length) {\n            // 根据数值个数使用对应的色板\n            attrCfg.values = scales[0].values.length <= 10 ? theme.colors10 : theme.colors20;\n          } else {\n            attrCfg.values = theme.colors10;\n          }\n        }\n      }\n\n      var AttributeCtor = getAttributeClass(attrType);\n      attributes[attrType] = new AttributeCtor(attrCfg);\n    });\n  }; // 处理数据：分组 -> 数字化 -> adjust 调整\n\n\n  Geometry.prototype.processData = function (data) {\n    var _this = this;\n\n    var groupedArray = this.groupData(data); // 数据分组\n\n    groupedArray = map(groupedArray, function (subData) {\n      var tempData = _this.saveOrigin(subData); // 存储原始数据\n\n\n      _this.numeric(tempData); // 将分类数据转换成数字\n\n\n      return tempData;\n    });\n    var dataArray = this.adjustData(groupedArray); // 进行 adjust 数据调整\n\n    this.beforeMappingData = dataArray;\n    return dataArray;\n  }; // 调整数据\n\n\n  Geometry.prototype.adjustData = function (dataArray) {\n    var _this = this;\n\n    var adjustOption = this.adjustOption;\n    var result = dataArray;\n\n    if (adjustOption) {\n      var xScale_1 = this.getXScale();\n      var yScale_1 = this.getYScale();\n      var xField_1 = xScale_1.field;\n      var yField_1 = yScale_1 ? yScale_1.field : null;\n      adjustOption.forEach(function (adjust) {\n        var adjustCfg = __assign({\n          xField: xField_1,\n          yField: yField_1\n        }, adjust);\n\n        var type = adjust.type;\n\n        if (type === 'dodge') {\n          var adjustNames = [];\n\n          if (xScale_1.isCategory || xScale_1.type === 'identity') {\n            adjustNames.push('x');\n          } else if (!yScale_1) {\n            adjustNames.push('y');\n          } else {\n            throw new Error('dodge is not support linear attribute, please use category attribute!');\n          }\n\n          adjustCfg.adjustNames = adjustNames; // 每个分组内每条柱子的宽度占比，用户不可指定，用户需要通过 columnWidthRatio 指定\n\n          adjustCfg.dodgeRatio = _this.theme.columnWidthRatio;\n        } else if (type === 'stack') {\n          var coordinate = _this.coordinate;\n\n          if (!yScale_1) {\n            // 一维的情况下获取高度和默认size\n            adjustCfg.height = coordinate.getHeight();\n            var size = _this.getDefaultValue('size') || 3;\n            adjustCfg.size = size;\n          } // 不进行 transpose 时，用户又没有设置这个参数时，默认从上向下\n\n\n          if (!coordinate.isTransposed && isNil(adjustCfg.reverseOrder)) {\n            adjustCfg.reverseOrder = true;\n          }\n        }\n\n        var adjustCtor = getAdjustClass(type);\n        var adjustInstance = new adjustCtor(adjustCfg);\n        result = adjustInstance.process(result);\n        _this.adjusts[type] = adjustInstance;\n      });\n    }\n\n    return result;\n  }; // 对数据进行分组\n\n\n  Geometry.prototype.groupData = function (data) {\n    var groupScales = this.getGroupScales();\n    var scaleDefs = this.scaleDefs;\n    var appendConditions = {};\n    var groupFields = [];\n\n    for (var _i = 0, groupScales_1 = groupScales; _i < groupScales_1.length; _i++) {\n      var scale = groupScales_1[_i];\n      var field = scale.field;\n      groupFields.push(field);\n\n      if (get(scaleDefs, [field, 'values'])) {\n        // 用户通过 view.scale() 接口指定了 values 属性\n        appendConditions[field] = scaleDefs[field].values;\n      }\n    }\n\n    return group(data, groupFields, appendConditions);\n  }; // 数据调整前保存原始数据\n\n\n  Geometry.prototype.saveOrigin = function (data) {\n    return map(data, function (originData) {\n      var _a;\n\n      return __assign(__assign({}, originData), (_a = {}, _a[FIELD_ORIGIN] = originData, _a));\n    });\n  }; // 将分类数据翻译成数据, 仅对位置相关的度量进行数字化处理\n\n\n  Geometry.prototype.numeric = function (data) {\n    var positionAttr = this.getAttribute('position');\n    var scales = positionAttr.scales;\n\n    for (var j = 0, len = data.length; j < len; j += 1) {\n      var obj = data[j];\n\n      for (var i = 0; i < Math.min(2, scales.length); i += 1) {\n        var scale = scales[i];\n\n        if (scale.isCategory) {\n          var field = scale.field;\n          obj[field] = scale.translate(obj[field]);\n        }\n      }\n    }\n  }; // 更新发生层叠后的数据对应的度量范围\n\n\n  Geometry.prototype.updateStackRange = function (scale, dataArray) {\n    var mergeArray = flatten(dataArray);\n    var field = scale.field;\n    var min = scale.min;\n    var max = scale.max;\n\n    for (var _i = 0, mergeArray_1 = mergeArray; _i < mergeArray_1.length; _i++) {\n      var obj = mergeArray_1[_i];\n      var tmpMin = Math.min.apply(null, obj[field]);\n      var tmpMax = Math.max.apply(null, obj[field]);\n\n      if (tmpMin < min) {\n        min = tmpMin;\n      }\n\n      if (tmpMax > max) {\n        max = tmpMax;\n      }\n    }\n\n    var scaleDefs = this.scaleDefs;\n    var cfg = {};\n\n    if (min < scale.min && !get(scaleDefs, [field, 'min'])) {\n      // 用户如果在列定义中定义了 min，则以用户定义的为准\n      cfg.min = min;\n    }\n\n    if (max > scale.max && !get(scaleDefs, [field, 'max'])) {\n      // 用户如果在列定义中定义了 max\n      cfg.max = max;\n    }\n\n    scale.change(cfg);\n  }; // 将数据映射至图形空间前的操作：排序以及关键点的生成\n\n\n  Geometry.prototype.beforeMapping = function (beforeMappingData) {\n    var _this = this; // 当初加 clone 是因为 points 的引用关系，导致更新失败，可是现在貌似复现不出来了，所以暂时不进行 clone\n    // const source = clone(beforeMappingData);\n\n\n    var source = beforeMappingData;\n\n    if (this.sortable) {\n      var xScale_2 = this.getXScale();\n      var field_1 = xScale_2.field;\n      each(source, function (data) {\n        data.sort(function (v1, v2) {\n          return xScale_2.translate(v1[field_1]) - xScale_2.translate(v2[field_1]);\n        });\n      });\n    }\n\n    if (this.generatePoints) {\n      // 需要生成关键点\n      each(source, function (data) {\n        _this.generateShapePoints(data);\n      });\n      source.reduce(function (preData, currentData) {\n        preData[0].nextPoints = currentData[0].points;\n        return currentData;\n      }, source[0]);\n    }\n\n    return source;\n  }; // 映射完毕后，对最后的结果集进行排序，方便后续 tooltip 的数据查找\n\n\n  Geometry.prototype.afterMapping = function (mappingArray) {\n    if (!this.sortable) {\n      this.sort(mappingArray);\n    }\n\n    this.dataArray = mappingArray;\n  }; // 生成 shape 的关键点\n\n\n  Geometry.prototype.generateShapePoints = function (data) {\n    var shapeFactory = this.getShapeFactory();\n    var shapeAttr = this.getAttribute('shape');\n\n    for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n      var obj = data_1[_i];\n      var cfg = this.createShapePointsCfg(obj);\n      var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;\n      var points = shapeFactory.getShapePoints(shape, cfg);\n      obj.points = points;\n    }\n  }; // 将数据归一化\n\n\n  Geometry.prototype.normalizeValues = function (values, scale) {\n    var rst = [];\n\n    if (isArray(values)) {\n      rst = values.map(function (v) {\n        return scale.scale(v);\n      });\n    } else {\n      rst = scale.scale(values);\n    }\n\n    return rst;\n  }; // 将数据映射至图形空间\n\n\n  Geometry.prototype.mapping = function (data) {\n    var attributes = this.attributes;\n    var mappingData = [];\n\n    for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {\n      var record = data_2[_i];\n      var newRecord = {\n        _origin: record[FIELD_ORIGIN],\n        points: record.points,\n        nextPoints: record.nextPoints\n      };\n\n      for (var k in attributes) {\n        if (attributes.hasOwnProperty(k)) {\n          var attr = attributes[k];\n          var names = attr.names;\n          var values = this.getAttributeValues(attr, record);\n\n          if (names.length > 1) {\n            // position 之类的生成多个字段的属性\n            for (var j = 0; j < values.length; j += 1) {\n              var val = values[j];\n              var name_1 = names[j];\n              newRecord[name_1] = isArray(val) && val.length === 1 ? val[0] : val; // 只有一个值时返回第一个属性值\n            }\n          } else {\n            // values.length === 1 的判断是以下情况，获取用户设置的图形属性值\n            // shape('a', ['dot', 'dash']), color('a', ['red', 'yellow'])\n            newRecord[names[0]] = values.length === 1 ? values[0] : values;\n          }\n        }\n      }\n\n      this.convertPoint(newRecord); // 将 x、y 转换成画布坐标\n\n      mappingData.push(newRecord);\n    }\n\n    return mappingData;\n  }; // 将归一化的坐标值转换成画布坐标\n\n\n  Geometry.prototype.convertPoint = function (mappingRecord) {\n    var x = mappingRecord.x,\n        y = mappingRecord.y;\n\n    if (isNil(x) || isNil(y)) {\n      return;\n    }\n\n    var rstX;\n    var rstY;\n    var obj;\n    var coordinate = this.coordinate;\n\n    if (isArray(y) && isArray(x)) {\n      rstX = [];\n      rstY = [];\n\n      for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {\n        obj = coordinate.convert({\n          x: x[i],\n          y: y[j]\n        });\n        rstX.push(obj.x);\n        rstY.push(obj.y);\n      }\n    } else if (isArray(y)) {\n      rstY = [];\n      y.forEach(function (yVal) {\n        obj = coordinate.convert({\n          x: x,\n          y: yVal\n        });\n\n        if (rstX && rstX !== obj.x) {\n          if (!isArray(rstX)) {\n            rstX = [rstX];\n          }\n\n          rstX.push(obj.x);\n        } else {\n          rstX = obj.x;\n        }\n\n        rstY.push(obj.y);\n      });\n    } else if (isArray(x)) {\n      rstX = [];\n      x.forEach(function (xVal) {\n        obj = coordinate.convert({\n          x: xVal,\n          y: y\n        });\n\n        if (rstY && rstY !== obj.y) {\n          if (!isArray(rstY)) {\n            rstY = [rstY];\n          }\n\n          rstY.push(obj.y);\n        } else {\n          rstY = obj.y;\n        }\n\n        rstX.push(obj.x);\n      });\n    } else {\n      var point = coordinate.convert({\n        x: x,\n        y: y\n      });\n      rstX = point.x;\n      rstY = point.y;\n    }\n\n    mappingRecord.x = rstX;\n    mappingRecord.y = rstY;\n  }; // 对数据进行排序\n\n\n  Geometry.prototype.sort = function (mappingArray) {\n    var xScale = this.getXScale();\n    var xField = xScale.field;\n    each(mappingArray, function (itemArr) {\n      itemArr.sort(function (obj1, obj2) {\n        return xScale.translate(obj1[FIELD_ORIGIN][xField]) - xScale.translate(obj2[FIELD_ORIGIN][xField]);\n      });\n    });\n  }; // 获取 style 配置\n\n\n  Geometry.prototype.getStyleCfg = function (styleOption, originData) {\n    var _a = styleOption.fields,\n        fields = _a === void 0 ? [] : _a,\n        callback = styleOption.callback,\n        cfg = styleOption.cfg;\n\n    if (cfg) {\n      // 用户直接配置样式属性\n      return cfg;\n    }\n\n    var params = fields.map(function (field) {\n      return originData[field];\n    });\n    return callback.apply(void 0, params);\n  };\n\n  Geometry.prototype.setCfg = function (cfg) {\n    var _this = this;\n\n    var coordinate = cfg.coordinate,\n        data = cfg.data,\n        theme = cfg.theme,\n        scaleDefs = cfg.scaleDefs;\n\n    if (coordinate) {\n      this.coordinate = coordinate;\n    }\n\n    if (data) {\n      this.data = data;\n    }\n\n    if (scaleDefs) {\n      this.scaleDefs = scaleDefs;\n      this.idFields = [];\n      each(scaleDefs, function (scaleDef, field) {\n        if (get(scaleDef, 'key')) {\n          _this.idFields.push(field);\n        }\n      });\n    }\n\n    if (theme) {\n      this.theme = this.userTheme ? deepMix({}, theme, this.userTheme) : theme; // 支持 geometry 层级的主题设置\n    }\n  };\n\n  Geometry.prototype.renderLabels = function (mappingArray, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n\n    var geometryLabel = this.geometryLabel;\n\n    if (!geometryLabel) {\n      // 初次创建\n      var labelType = this.getLabelType();\n      var GeometryLabelsCtor = getGeometryLabel(labelType);\n      geometryLabel = new GeometryLabelsCtor(this);\n      this.geometryLabel = geometryLabel;\n    }\n\n    geometryLabel.render(mappingArray, isUpdate); // 将 label 同 element 进行关联\n\n    var labelsMap = geometryLabel.labelsRenderer.shapesMap;\n    each(this.elementsMap, function (element, id) {\n      var labels = filterLabelsById(id, labelsMap); // element 实例同 label 进行绑定\n\n      element.labelShape = labels;\n\n      if (labels.length) {\n        each(labels, function (label) {\n          var children = label.getChildren();\n          each(children, function (child) {\n            child.set('element', element);\n          });\n        });\n      }\n    });\n  };\n  /**\n   * 是否需要进行群组入场动画\n   * 规则：\n   * 1. 如果发生更新，则不进行\n   * 2. 如果用户关闭 geometry 动画，则不进行\n   * 3. 如果用户关闭了 appear 动画，则不进行\n   * 4. 如果用户配置了 appear.animation，则不进行\n   */\n\n\n  Geometry.prototype.canDoGroupAnimation = function (isUpdate) {\n    return !isUpdate && this.animateOption && (get(this.animateOption, 'appear') === undefined || get(this.animateOption, 'appear') && get(this.animateOption, ['appear', 'animation']) === undefined);\n  };\n\n  return Geometry;\n}(Base);\n\nexport default Geometry;","map":{"version":3,"sources":["../../src/geometry/base.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { getAdjust as getAdjustClass } from '@antv/adjust';\nimport { getAttribute as getAttributeClass } from '@antv/attr';\nimport { clone, deepMix, each, flatten, get, isArray, isEmpty, isEqual, isFunction, isNil, isNumber, isObject, isPlainObject, isString, map, set, uniq, } from '@antv/util';\nimport { doGroupAppearAnimate } from '../animate';\nimport Base from '../base';\nimport { FIELD_ORIGIN, GROUP_ATTRS } from '../constant';\nimport Element from './element';\nimport { getGeometryLabel } from './label';\nimport { getShapeFactory } from './shape/base';\nimport { group } from './util/group-data';\nimport { isModelChange } from './util/is-model-change';\nimport { parseFields } from './util/parse-fields';\n// 根据 elementId 查找对应的 label，因为有可能一个 element 对应多个 labels，所以在给 labels 打标识时做了处理\n// 打标规则详见 ./label/base.ts#L263\nfunction filterLabelsById(id, labelsMap) {\n    var labels = [];\n    each(labelsMap, function (label, labelId) {\n        var elementId = labelId.split(' ')[0];\n        if (elementId === id) {\n            labels.push(label);\n        }\n    });\n    return labels;\n}\n/**\n * Geometry 几何标记基类，主要负责数据到图形属性的映射以及绘制逻辑。\n */\nvar Geometry = /** @class */ (function (_super) {\n    __extends(Geometry, _super);\n    /**\n     * 创建 Geometry 实例。\n     * @param cfg\n     */\n    function Geometry(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        /** Geometry 几何标记类型。 */\n        _this.type = 'base';\n        // 内部产生的属性\n        /** Attribute map  */\n        _this.attributes = {};\n        /** Element map */\n        _this.elements = [];\n        /** animate 配置项 */\n        _this.animateOption = true;\n        /** 使用 key-value 结构存储 Element，key 为每个 Element 实例对应的唯一 ID */\n        _this.elementsMap = {};\n        /** 图形属性映射配置 */\n        _this.attributeOption = {};\n        /** 存储上一次渲染时的 element 映射表，用于更新逻辑 */\n        _this.lastElementsMap = {};\n        /** 是否生成多个点来绘制图形。 */\n        _this.generatePoints = false;\n        /** 存储发生图形属性映射前的数据 */\n        _this.beforeMappingData = null;\n        _this.adjusts = {};\n        _this.idFields = [];\n        var container = cfg.container, labelsContainer = cfg.labelsContainer, coordinate = cfg.coordinate, data = cfg.data, _a = cfg.sortable, sortable = _a === void 0 ? false : _a, _b = cfg.visible, visible = _b === void 0 ? true : _b, theme = cfg.theme, _c = cfg.scales, scales = _c === void 0 ? {} : _c, _d = cfg.scaleDefs, scaleDefs = _d === void 0 ? {} : _d;\n        _this.container = container;\n        _this.labelsContainer = labelsContainer;\n        _this.coordinate = coordinate;\n        _this.data = data;\n        _this.sortable = sortable;\n        _this.visible = visible;\n        _this.userTheme = theme;\n        _this.scales = scales;\n        _this.scaleDefs = scaleDefs;\n        return _this;\n    }\n    /**\n     * 配置 position 通道映射规则。\n     *\n     * @example\n     * ```typescript\n     * // 数据结构: [{ x: 'A', y: 10, color: 'red' }]\n     * geometry.position('x*y');\n     * geometry.position([ 'x', 'y' ]);\n     * geometry.position({\n     *   fields: [ 'x', 'y' ],\n     * });\n     * ```\n     *\n     * @param cfg 映射规则\n     * @returns\n     */\n    Geometry.prototype.position = function (cfg) {\n        var positionCfg = cfg;\n        if (!isPlainObject(cfg)) {\n            // 字符串字段或者数组字段\n            positionCfg = {\n                fields: parseFields(cfg),\n            };\n        }\n        var fields = get(positionCfg, 'fields');\n        if (fields.length === 1) {\n            // 默认填充一维 1*xx\n            fields.unshift('1');\n            set(positionCfg, 'fields', fields);\n        }\n        set(this.attributeOption, 'position', positionCfg);\n        return this;\n    };\n    Geometry.prototype.color = function (field, cfg) {\n        this.createAttrOption('color', field, cfg);\n        return this;\n    };\n    Geometry.prototype.shape = function (field, cfg) {\n        this.createAttrOption('shape', field, cfg);\n        return this;\n    };\n    Geometry.prototype.size = function (field, cfg) {\n        this.createAttrOption('size', field, cfg);\n        return this;\n    };\n    /**\n     * 设置数据调整方式。G2 目前内置了四种类型：\n     * 1. dodge\n     * 2. stack\n     * 3. symmetric\n     * 4. jitter\n     *\n     *\n     * **Tip**\n     * + 对于 'dodge' 类型，可以额外进行如下属性的配置:\n     * ```typescript\n     * geometry.adjust('dodge', {\n     *   marginRatio: 0, // 取 0 到 1 范围的值（相对于每个柱子宽度），用于控制一个分组中柱子之间的间距\n     *   dodgeBy: 'x', // 该属性只对 'dodge' 类型生效，声明以哪个数据字段为分组依据\n     * });\n     * ```\n     *\n     * + 对于 'stack' 类型，可以额外进行如下属性的配置:\n     * ```typescript\n     * geometry.adjust('stack', {\n     *   reverseOrder: false, // 用于控制是否对数据进行反序操作\n     * });\n     * ```\n     *\n     * @example\n     * ```typescript\n     * geometry.adjust('stack');\n     *\n     * geometry.adjust({\n     *   type: 'stack',\n     *   reverseOrder: false,\n     * });\n     *\n     * // 组合使用 adjust\n     * geometry.adjust([ 'stack', 'dodge' ]);\n     *\n     * geometry.adjust([\n     *   { type: 'stack' },\n     *   { type: 'dodge', dodgeBy: 'x' },\n     * ]);\n     * ```\n     *\n     * @param adjustCfg 数据调整配置\n     * @returns\n     */\n    Geometry.prototype.adjust = function (adjustCfg) {\n        var adjusts = adjustCfg;\n        if (isString(adjustCfg) || isPlainObject(adjustCfg)) {\n            adjusts = [adjustCfg];\n        }\n        each(adjusts, function (adjust, index) {\n            if (!isObject(adjust)) {\n                adjusts[index] = { type: adjust };\n            }\n        });\n        this.adjustOption = adjusts;\n        return this;\n    };\n    Geometry.prototype.style = function (field, styleFunc) {\n        if (isString(field)) {\n            var fields = parseFields(field);\n            this.styleOption = {\n                fields: fields,\n                callback: styleFunc,\n            };\n        }\n        else {\n            var _a = field, fields = _a.fields, callback = _a.callback, cfg = _a.cfg;\n            if (fields || callback || cfg) {\n                this.styleOption = field;\n            }\n            else {\n                this.styleOption = {\n                    cfg: field,\n                };\n            }\n        }\n        return this;\n    };\n    Geometry.prototype.tooltip = function (field, cfg) {\n        if (isString(field)) {\n            var fields = parseFields(field);\n            this.tooltipOption = {\n                fields: fields,\n                callback: cfg,\n            };\n        }\n        else {\n            this.tooltipOption = field;\n        }\n        return this;\n    };\n    /**\n     * Geometry 动画配置。\n     *\n     * + `animate(false)` 关闭动画\n     * + `animate(true)` 开启动画，默认开启。\n     *\n     * 我们将动画分为四个场景：\n     * 1. appear: 图表第一次加载时的入场动画；\n     * 2. enter: 图表绘制完成，发生更新后，产生的新图形的进场动画；\n     * 3. update: 图表绘制完成，数据发生变更后，有状态变更的图形的更新动画；\n     * 4. leave: 图表绘制完成，数据发生变更后，被销毁图形的销毁动画。\n     *\n     * @example\n     * ```typescript\n     * animate({\n     *   enter: {\n     *     duration: 1000, // enter 动画执行时间\n     *   },\n     *   leave: false, // 关闭 leave 销毁动画\n     * });\n     * ```\n     *\n     * @param cfg 动画配置\n     * @returns\n     */\n    Geometry.prototype.animate = function (cfg) {\n        this.animateOption = cfg;\n        return this;\n    };\n    Geometry.prototype.label = function (field, secondParam, thirdParam) {\n        if (isString(field)) {\n            var labelOption = {};\n            var fields = parseFields(field);\n            labelOption.fields = fields;\n            if (isFunction(secondParam)) {\n                labelOption.callback = secondParam;\n            }\n            else if (isPlainObject(secondParam)) {\n                labelOption.cfg = secondParam;\n            }\n            if (thirdParam) {\n                labelOption.cfg = thirdParam;\n            }\n            this.labelOption = labelOption;\n        }\n        else {\n            this.labelOption = field;\n        }\n        return this;\n    };\n    /**\n     * 设置状态对应的样式。\n     *\n     * @example\n     * ```ts\n     * chart.interval().state({\n     *   selected: {\n     *     animate: { duration: 100, easing: 'easeLinear' },\n     *     style: {\n     *       lineWidth: 2,\n     *       stroke: '#000',\n     *     },\n     *   },\n     * });\n     * ```\n     *\n     * 如果图形 shape 是由多个 shape 组成，即为一个 G.Group 对象，那么针对 group 中的每个 shape，我们需要使用下列方式进行状态样式设置：\n     * 如果我们为 group 中的每个 shape 设置了 'name' 属性(shape.set('name', 'xx'))，则以 'name' 作为 key，否则默认以索引值（即 shape 的 添加顺序）为 key。\n     *\n     * ```ts\n     * chart.interval().shape('groupShape').state({\n     *   selected: {\n     *     style: {\n     *       0: { lineWidth: 2 },\n     *       1: { fillOpacity: 1 },\n     *     }\n     *   }\n     * });\n     * ```\n     *\n     * @param cfg 状态样式\n     */\n    Geometry.prototype.state = function (cfg) {\n        this.stateOption = cfg;\n        return this;\n    };\n    /**\n     * 初始化 Geomtry 实例：\n     * 创建 [[Attribute]] and [[Scale]] 实例，进行数据处理，包括分组、数值化以及数据调整。\n     */\n    Geometry.prototype.init = function (cfg) {\n        if (cfg === void 0) { cfg = {}; }\n        this.setCfg(cfg);\n        this.initAttributes(); // 创建图形属性\n        // 数据加工：分组 -> 数字化 -> adjust\n        this.processData(this.data);\n        // 调整 scale\n        this.adjustScale();\n    };\n    /**\n     * Geometry 更新。\n     * @param [cfg] 更新的配置\n     */\n    Geometry.prototype.update = function (cfg) {\n        if (cfg === void 0) { cfg = {}; }\n        var data = cfg.data, isDataChanged = cfg.isDataChanged;\n        var _a = this, attributeOption = _a.attributeOption, lastAttributeOption = _a.lastAttributeOption;\n        if (!isEqual(attributeOption, lastAttributeOption)) {\n            // 映射发生改变，则重新创建图形属性\n            this.init(cfg);\n        }\n        else if (data && (isDataChanged || !isEqual(data, this.data))) {\n            // 数据发生变化\n            this.setCfg(cfg);\n            this.processData(data); // 数据加工：分组 -> 数字化 -> adjust\n        }\n        else {\n            // 有可能 coordinate 变化\n            this.setCfg(cfg);\n        }\n        // 调整 scale\n        this.adjustScale();\n    };\n    /**\n     * 将原始数据映射至图形空间，同时创建图形对象。\n     */\n    Geometry.prototype.paint = function (isUpdate) {\n        var _this = this;\n        if (isUpdate === void 0) { isUpdate = false; }\n        this.defaultSize = undefined;\n        this.elements = [];\n        this.elementsMap = {};\n        var offscreenGroup = this.getOffscreenGroup();\n        offscreenGroup.clear();\n        var beforeMappingData = this.beforeMappingData;\n        var dataArray = this.beforeMapping(beforeMappingData);\n        var mappingArray = [];\n        dataArray.forEach(function (eachGroup, index) {\n            var mappingData = _this.mapping(eachGroup);\n            mappingArray.push(mappingData);\n            _this.createElements(mappingData, index, isUpdate);\n        });\n        if (this.canDoGroupAnimation(isUpdate)) {\n            // 如果用户没有配置 appear.animation，就默认走整体动画\n            var container = this.container;\n            var type = this.type;\n            var coordinate = this.coordinate;\n            var animateCfg = get(this.animateOption, 'appear');\n            var yScale = this.getYScale();\n            var yMinPoint = coordinate.convert({\n                x: 0,\n                y: yScale.scale(this.getYMinValue()),\n            });\n            doGroupAppearAnimate(container, animateCfg, type, coordinate, yMinPoint);\n        }\n        // 添加 label\n        if (this.labelOption) {\n            this.renderLabels(flatten(mappingArray), isUpdate);\n        }\n        this.afterMapping(mappingArray);\n        // 销毁被删除的 elements\n        each(this.lastElementsMap, function (deletedElement) {\n            // 更新动画配置，用户有可能在更新之前有对动画进行配置操作\n            deletedElement.animate = _this.animateOption;\n            deletedElement.destroy();\n        });\n        this.lastElementsMap = this.elementsMap;\n        // 缓存，用于更新\n        this.lastAttributeOption = __assign({}, this.attributeOption);\n        if (this.visible === false) {\n            // 用户在初始化的时候声明 visible: false\n            this.changeVisible(false);\n        }\n    };\n    /**\n     * 清空当前 Geometry，配置项仍保留，但是内部创建的对象全部清空。\n     * @override\n     */\n    Geometry.prototype.clear = function () {\n        var _a = this, container = _a.container, geometryLabel = _a.geometryLabel;\n        if (container) {\n            container.clear();\n        }\n        if (geometryLabel) {\n            geometryLabel.clear();\n        }\n        // 属性恢复至出厂状态\n        this.attributes = {};\n        this.scales = {};\n        this.elementsMap = {};\n        this.lastElementsMap = {};\n        this.elements = [];\n        this.dataArray = null;\n        this.beforeMappingData = null;\n        this.lastAttributeOption = undefined;\n        this.defaultSize = undefined;\n        this.idFields = [];\n    };\n    /**\n     * 销毁 Geometry 实例。\n     */\n    Geometry.prototype.destroy = function () {\n        this.clear();\n        var container = this.container;\n        container.remove(true);\n        if (this.offscreenGroup) {\n            this.offscreenGroup.remove(true);\n            this.offscreenGroup = null;\n        }\n        if (this.geometryLabel) {\n            this.geometryLabel.destroy();\n            this.geometryLabel = null;\n        }\n        this.theme = undefined;\n        _super.prototype.destroy.call(this);\n    };\n    /**\n     * 获取决定分组的图形属性对应的 scale 实例。\n     * @returns\n     */\n    Geometry.prototype.getGroupScales = function () {\n        var scales = [];\n        var attributes = this.attributes;\n        each(attributes, function (attr) {\n            if (GROUP_ATTRS.includes(attr.type)) {\n                var attrScales = attr.scales;\n                each(attrScales, function (scale) {\n                    if (scale.isCategory && !scales.includes(scale)) {\n                        scales.push(scale);\n                    }\n                });\n            }\n        });\n        return scales;\n    };\n    /**\n     * 根据名字获取图形属性实例。\n     */\n    Geometry.prototype.getAttribute = function (name) {\n        return this.attributes[name];\n    };\n    /** 获取 x 轴对应的 scale 实例。 */\n    Geometry.prototype.getXScale = function () {\n        return this.getAttribute('position').scales[0];\n    };\n    /** 获取 y 轴对应的 scale 实例。 */\n    Geometry.prototype.getYScale = function () {\n        return this.getAttribute('position').scales[1];\n    };\n    /**\n     * 获取决定分组的图形属性实例。\n     */\n    Geometry.prototype.getGroupAttributes = function () {\n        var rst = [];\n        each(this.attributes, function (attr) {\n            if (GROUP_ATTRS.includes(attr.type)) {\n                rst.push(attr);\n            }\n        });\n        return rst;\n    };\n    /** 获取图形属性默认的映射值。 */\n    Geometry.prototype.getDefaultValue = function (attrName) {\n        var value;\n        var attr = this.getAttribute(attrName);\n        if (attr && isEmpty(attr.scales)) {\n            // 获取映射至常量的值\n            value = attr.values[0];\n        }\n        return value;\n    };\n    /**\n     * 获取该数据发生图形映射后对应的 Attribute 图形空间数据。\n     * @param attr Attribute 图形属性实例。\n     * @param obj 需要进行映射的原始数据。\n     * @returns\n     */\n    Geometry.prototype.getAttributeValues = function (attr, obj) {\n        var scales = attr.scales;\n        var params = map(scales, function (scale) {\n            var field = scale.field;\n            if (scale.type === 'identity') {\n                return scale.values[0];\n            }\n            if (scale.isCategory) {\n                return obj[field]; // 数据有可能发生过 adjust\n            }\n            return obj[field];\n        });\n        return attr.mapping.apply(attr, params);\n    };\n    Geometry.prototype.getAdjust = function (adjustType) {\n        return this.adjusts[adjustType];\n    };\n    /**\n     * 获取 shape 对应的 marker 样式。\n     * @param shapeName shape 具体名字\n     * @param cfg marker 信息\n     * @returns\n     */\n    Geometry.prototype.getShapeMarker = function (shapeName, cfg) {\n        var shapeFactory = this.getShapeFactory();\n        return shapeFactory.getMarker(shapeName, cfg);\n    };\n    /**\n     * 根据一定的规则查找 Geometry 的 Elements。\n     *\n     * ```typescript\n     * getElementsBy((element) => {\n     *   const data = element.getData();\n     *\n     *   return data.a === 'a';\n     * });\n     * ```\n     *\n     * @param condition 定义查找规则的回调函数。\n     * @returns\n     */\n    Geometry.prototype.getElementsBy = function (condition) {\n        return this.elements.filter(function (element) {\n            return condition(element);\n        });\n    };\n    /**\n     * 获取数据对应的唯一 id。\n     * @param data Element 对应的绘制数据\n     * @returns\n     */\n    Geometry.prototype.getElementId = function (data) {\n        data = isArray(data) ? data[0] : data;\n        var originData = data[FIELD_ORIGIN];\n        // 如果用户声明了使用哪些字段作为 id 值\n        if (this.idFields.length) {\n            var elementId = originData[this.idFields[0]];\n            for (var index = 1; index < this.idFields.length; index++) {\n                elementId += '-' + originData[this.idFields[index]];\n            }\n            return elementId;\n        }\n        var type = this.type;\n        var xScale = this.getXScale();\n        var yScale = this.getYScale();\n        var xField = xScale.field || 'x';\n        var yField = yScale.field || 'y';\n        var yVal = originData[yField];\n        var xVal;\n        if (xScale.type === 'identity') {\n            xVal = xScale.values[0];\n        }\n        else {\n            xVal = originData[xField];\n        }\n        var id;\n        if (type === 'interval' || type === 'schema') {\n            id = xVal;\n        }\n        else if (type === 'line' || type === 'area' || type === 'path') {\n            id = type;\n        }\n        else {\n            id = xVal + \"-\" + yVal;\n        }\n        var groupScales = this.getGroupScales();\n        if (!isEmpty(groupScales)) {\n            each(groupScales, function (groupScale) {\n                var field = groupScale.field;\n                if (groupScale.type !== 'identity') {\n                    id = id + \"-\" + originData[field];\n                }\n            });\n        }\n        // 用户在进行 dodge 类型的 adjust 调整的时候设置了 dodgeBy 属性\n        var dodgeAdjust = this.getAdjust('dodge');\n        if (dodgeAdjust) {\n            var dodgeBy = dodgeAdjust.dodgeBy;\n            if (dodgeBy) {\n                id = id + \"-\" + originData[dodgeBy];\n            }\n        }\n        if (this.getAdjust('jitter')) {\n            id = id + \"-\" + data.x + \"-\" + data.y;\n        }\n        return id;\n    };\n    /**\n     * 获取所有需要创建 scale 的字段名称。\n     */\n    Geometry.prototype.getScaleFields = function () {\n        var fields = [];\n        var _a = this, attributeOption = _a.attributeOption, labelOption = _a.labelOption, tooltipOption = _a.tooltipOption;\n        each(attributeOption, function (eachOpt) {\n            // size(10)\n            fields = fields.concat(eachOpt.fields || eachOpt.values);\n        });\n        fields = fields.concat(get(labelOption, 'fields', []));\n        fields = fields.concat(get(tooltipOption, 'fields', []));\n        return uniq(fields);\n    };\n    /**\n     * 显示或者隐藏 geometry。\n     * @param visible\n     */\n    Geometry.prototype.changeVisible = function (visible) {\n        _super.prototype.changeVisible.call(this, visible);\n        this.elements.forEach(function (element) {\n            element.changeVisible(visible);\n        });\n        if (visible) {\n            if (this.container) {\n                this.container.show();\n            }\n            if (this.labelsContainer) {\n                this.labelsContainer.show();\n            }\n        }\n        else {\n            if (this.container) {\n                this.container.hide();\n            }\n            if (this.labelsContainer) {\n                this.labelsContainer.hide();\n            }\n        }\n    };\n    /**\n     * 获取当前配置中的所有分组 & 分类的字段。\n     * @return fields string[]\n     */\n    Geometry.prototype.getGroupFields = function () {\n        var _this = this;\n        var fields = [];\n        each(GROUP_ATTRS, function (attributeName) {\n            var cfg = _this.attributeOption[attributeName];\n            fields.push.apply(fields, get(cfg, 'fields', []));\n        });\n        return uniq(fields);\n    };\n    /**\n     * 获得图形的 x y 字段。\n     */\n    Geometry.prototype.getXYFields = function () {\n        var _a = this.attributeOption.position.fields, x = _a[0], y = _a[1];\n        return [x, y];\n    };\n    /**\n     * 获取该 Geometry 下所有生成的 shapes。\n     * @returns shapes\n     */\n    Geometry.prototype.getShapes = function () {\n        return this.elements.map(function (element) { return element.shape; });\n    };\n    /**\n     * 获取虚拟 Group。\n     * @returns\n     */\n    Geometry.prototype.getOffscreenGroup = function () {\n        if (!this.offscreenGroup) {\n            var GroupCtor = this.container.getGroupBase(); // 获取分组的构造函数\n            this.offscreenGroup = new GroupCtor({});\n        }\n        return this.offscreenGroup;\n    };\n    /**\n     * 调整度量范围。主要针对发生层叠以及一些特殊需求的 Geometry，比如 Interval 下的柱状图 Y 轴默认从 0 开始。\n     */\n    Geometry.prototype.adjustScale = function () {\n        var yScale = this.getYScale();\n        // 如果数据发生过 stack adjust，需要调整下 yScale 的数据范围\n        if (this.getAdjust('stack') && yScale) {\n            this.updateStackRange(yScale, this.beforeMappingData);\n        }\n    };\n    /**\n     * 获取当前 Geometry 对应的 Shape 工厂实例。\n     */\n    Geometry.prototype.getShapeFactory = function () {\n        var shapeType = this.shapeType;\n        if (!getShapeFactory(shapeType)) {\n            return;\n        }\n        if (!this.shapeFactory) {\n            this.shapeFactory = clone(getShapeFactory(shapeType)); // 防止多个 view 共享一个 shapeFactory 实例，导致 coordinate 被篡改\n        }\n        // 因为这里缓存了 shapeFactory，但是外部可能会变更 coordinate，导致无法重新设置到 shapeFactory 中\n        this.shapeFactory.coordinate = this.coordinate;\n        // theme 原因同上\n        this.shapeFactory.theme = get(this.theme, ['geometries', shapeType], {});\n        return this.shapeFactory;\n    };\n    /**\n     * 获取每个 Shape 对应的关键点数据。\n     * @param obj 经过分组 -> 数字化 -> adjust 调整后的数据记录\n     * @returns\n     */\n    Geometry.prototype.createShapePointsCfg = function (obj) {\n        var xScale = this.getXScale();\n        var yScale = this.getYScale();\n        var x = this.normalizeValues(obj[xScale.field], xScale);\n        var y; // 存在没有 y 的情况\n        if (yScale) {\n            y = this.normalizeValues(obj[yScale.field], yScale);\n        }\n        else {\n            y = obj.y ? obj.y : 0.1;\n        }\n        return {\n            x: x,\n            y: y,\n            y0: yScale ? yScale.scale(this.getYMinValue()) : undefined,\n        };\n    };\n    /**\n     * 创建 Element 实例。\n     * @param mappingDatum Element 对应的绘制数据\n     * @param [isUpdate] 是否处于更新阶段\n     * @returns element 返回创建的 Element 实例\n     */\n    Geometry.prototype.createElement = function (mappingDatum, isUpdate) {\n        if (isUpdate === void 0) { isUpdate = false; }\n        var _a = this, theme = _a.theme, container = _a.container;\n        var shapeCfg = this.getDrawCfg(mappingDatum); // 获取绘制图形的配置信息\n        var shapeFactory = this.getShapeFactory();\n        var element = new Element({\n            theme: get(theme, ['geometries', this.shapeType], {}),\n            shapeFactory: shapeFactory,\n            container: container,\n            offscreenGroup: this.getOffscreenGroup(),\n        });\n        element.geometry = this;\n        element.draw(shapeCfg, isUpdate); // 绘制\n        return element;\n    };\n    /**\n     * 获取每条数据对应的图形绘制数据。\n     * @param mappingDatum 映射后的数据\n     * @returns draw cfg\n     */\n    Geometry.prototype.getDrawCfg = function (mappingDatum) {\n        var originData = mappingDatum[FIELD_ORIGIN]; // 原始数据\n        var cfg = {\n            mappingData: mappingDatum,\n            data: originData,\n            x: mappingDatum.x,\n            y: mappingDatum.y,\n            color: mappingDatum.color,\n            size: mappingDatum.size,\n            isInCircle: this.coordinate.isPolar,\n        };\n        var shapeName = mappingDatum.shape;\n        if (!shapeName && this.getShapeFactory()) {\n            shapeName = this.getShapeFactory().defaultShapeType;\n        }\n        cfg.shape = shapeName;\n        // 获取默认样式\n        var theme = this.theme.geometries[this.shapeType];\n        cfg.defaultStyle = get(theme, [shapeName, 'default'], {}).style;\n        var styleOption = this.styleOption;\n        if (styleOption) {\n            cfg.style = this.getStyleCfg(styleOption, originData);\n        }\n        if (this.generatePoints) {\n            cfg.points = mappingDatum.points;\n            cfg.nextPoints = mappingDatum.nextPoints;\n        }\n        return cfg;\n    };\n    /**\n     * 创建所有的 Elements。\n     * @param mappingData\n     * @param [isUpdate]\n     * @returns elements\n     */\n    Geometry.prototype.createElements = function (mappingData, index, isUpdate) {\n        var _this = this;\n        if (isUpdate === void 0) { isUpdate = false; }\n        var _a = this, lastElementsMap = _a.lastElementsMap, elementsMap = _a.elementsMap, elements = _a.elements;\n        each(mappingData, function (mappingDatum, subIndex) {\n            var id = _this.getElementId(mappingDatum);\n            if (elementsMap[id]) {\n                // 存在重复数据，则根据再根据 index 进行区分\n                id = id + \"-\" + index + \"-\" + subIndex;\n            }\n            var result = lastElementsMap[id];\n            if (!result) {\n                // 创建新的 element\n                result = _this.createElement(mappingDatum, isUpdate);\n            }\n            else {\n                // element 已经创建\n                var currentShapeCfg = _this.getDrawCfg(mappingDatum);\n                var preShapeCfg = result.getModel();\n                if (isModelChange(currentShapeCfg, preShapeCfg)) {\n                    // 通过绘制数据的变更来判断是否需要更新，因为用户有可能会修改图形属性映射\n                    result.update(currentShapeCfg); // 更新对应的 element\n                }\n                delete lastElementsMap[id];\n            }\n            elements.push(result);\n            elementsMap[id] = result;\n        });\n        return elements;\n    };\n    /**\n     * 获取渲染的 label 类型。\n     */\n    Geometry.prototype.getLabelType = function () {\n        var _a = this, labelOption = _a.labelOption, coordinate = _a.coordinate, type = _a.type;\n        var coordinateType = coordinate.type;\n        var labelType = get(labelOption, ['cfg', 'type']);\n        if (!labelType) {\n            // 用户未定义，则进行默认的逻辑\n            if (coordinateType === 'polar') {\n                // 极坐标下使用通用的极坐标文本\n                labelType = 'polar';\n            }\n            else if (coordinateType === 'theta') {\n                // theta 坐标系下使用饼图文本\n                labelType = 'pie';\n            }\n            else if (type === 'interval' || type === 'polygon') {\n                labelType = 'interval';\n            }\n            else {\n                labelType = 'base';\n            }\n        }\n        return labelType;\n    };\n    /**\n     * 获取 Y 轴上的最小值。\n     */\n    Geometry.prototype.getYMinValue = function () {\n        var yScale = this.getYScale();\n        var min = yScale.min, max = yScale.max;\n        var value;\n        if (min >= 0) {\n            value = min;\n        }\n        else if (max <= 0) {\n            // 当值全位于负区间时，需要保证 ymin 在区域内，不可为 0\n            value = max;\n        }\n        else {\n            value = 0;\n        }\n        return value;\n    };\n    // 创建图形属性相关的配置项\n    Geometry.prototype.createAttrOption = function (attrName, field, cfg) {\n        if (isNil(field) || isObject(field)) {\n            if (isObject(field) && isEqual(Object.keys(field), ['values'])) {\n                // shape({ values: [ 'funnel' ] })\n                set(this.attributeOption, attrName, {\n                    fields: field.values,\n                });\n            }\n            else {\n                set(this.attributeOption, attrName, field);\n            }\n        }\n        else {\n            var attrCfg = {};\n            if (isNumber(field)) {\n                // size(3)\n                attrCfg.values = [field];\n            }\n            else {\n                attrCfg.fields = parseFields(field);\n            }\n            if (cfg) {\n                if (isFunction(cfg)) {\n                    attrCfg.callback = cfg;\n                }\n                else {\n                    attrCfg.values = cfg;\n                }\n            }\n            set(this.attributeOption, attrName, attrCfg);\n        }\n    };\n    Geometry.prototype.initAttributes = function () {\n        var _this = this;\n        var _a = this, attributes = _a.attributes, attributeOption = _a.attributeOption, theme = _a.theme, shapeType = _a.shapeType;\n        // 遍历每一个 attrOption，各自创建 Attribute 实例\n        each(attributeOption, function (option, attrType) {\n            if (!option) {\n                return;\n            }\n            var attrCfg = __assign({}, option);\n            var callback = attrCfg.callback, values = attrCfg.values, _a = attrCfg.fields, fields = _a === void 0 ? [] : _a;\n            // 获取每一个字段对应的 scale\n            var scales = map(fields, function (field) {\n                return _this.scales[field];\n            });\n            attrCfg.scales = scales;\n            if (attrType !== 'position' && scales.length === 1 && scales[0].type === 'identity') {\n                // 用户在图形通道上声明了常量字段 color('red'), size(5)\n                attrCfg.values = scales[0].values;\n            }\n            else if (!callback && !values) {\n                // 用户没有指定任何规则，则使用默认的映射规则\n                if (attrType === 'size') {\n                    attrCfg.values = theme.sizes;\n                }\n                else if (attrType === 'shape') {\n                    attrCfg.values = theme.shapes[shapeType] || [];\n                }\n                else if (attrType === 'color') {\n                    if (scales.length) {\n                        // 根据数值个数使用对应的色板\n                        attrCfg.values = scales[0].values.length <= 10 ? theme.colors10 : theme.colors20;\n                    }\n                    else {\n                        attrCfg.values = theme.colors10;\n                    }\n                }\n            }\n            var AttributeCtor = getAttributeClass(attrType);\n            attributes[attrType] = new AttributeCtor(attrCfg);\n        });\n    };\n    // 处理数据：分组 -> 数字化 -> adjust 调整\n    Geometry.prototype.processData = function (data) {\n        var _this = this;\n        var groupedArray = this.groupData(data); // 数据分组\n        groupedArray = map(groupedArray, function (subData) {\n            var tempData = _this.saveOrigin(subData); // 存储原始数据\n            _this.numeric(tempData); // 将分类数据转换成数字\n            return tempData;\n        });\n        var dataArray = this.adjustData(groupedArray); // 进行 adjust 数据调整\n        this.beforeMappingData = dataArray;\n        return dataArray;\n    };\n    // 调整数据\n    Geometry.prototype.adjustData = function (dataArray) {\n        var _this = this;\n        var adjustOption = this.adjustOption;\n        var result = dataArray;\n        if (adjustOption) {\n            var xScale_1 = this.getXScale();\n            var yScale_1 = this.getYScale();\n            var xField_1 = xScale_1.field;\n            var yField_1 = yScale_1 ? yScale_1.field : null;\n            adjustOption.forEach(function (adjust) {\n                var adjustCfg = __assign({ xField: xField_1,\n                    yField: yField_1 }, adjust);\n                var type = adjust.type;\n                if (type === 'dodge') {\n                    var adjustNames = [];\n                    if (xScale_1.isCategory || xScale_1.type === 'identity') {\n                        adjustNames.push('x');\n                    }\n                    else if (!yScale_1) {\n                        adjustNames.push('y');\n                    }\n                    else {\n                        throw new Error('dodge is not support linear attribute, please use category attribute!');\n                    }\n                    adjustCfg.adjustNames = adjustNames;\n                    // 每个分组内每条柱子的宽度占比，用户不可指定，用户需要通过 columnWidthRatio 指定\n                    adjustCfg.dodgeRatio = _this.theme.columnWidthRatio;\n                }\n                else if (type === 'stack') {\n                    var coordinate = _this.coordinate;\n                    if (!yScale_1) {\n                        // 一维的情况下获取高度和默认size\n                        adjustCfg.height = coordinate.getHeight();\n                        var size = _this.getDefaultValue('size') || 3;\n                        adjustCfg.size = size;\n                    }\n                    // 不进行 transpose 时，用户又没有设置这个参数时，默认从上向下\n                    if (!coordinate.isTransposed && isNil(adjustCfg.reverseOrder)) {\n                        adjustCfg.reverseOrder = true;\n                    }\n                }\n                var adjustCtor = getAdjustClass(type);\n                var adjustInstance = new adjustCtor(adjustCfg);\n                result = adjustInstance.process(result);\n                _this.adjusts[type] = adjustInstance;\n            });\n        }\n        return result;\n    };\n    // 对数据进行分组\n    Geometry.prototype.groupData = function (data) {\n        var groupScales = this.getGroupScales();\n        var scaleDefs = this.scaleDefs;\n        var appendConditions = {};\n        var groupFields = [];\n        for (var _i = 0, groupScales_1 = groupScales; _i < groupScales_1.length; _i++) {\n            var scale = groupScales_1[_i];\n            var field = scale.field;\n            groupFields.push(field);\n            if (get(scaleDefs, [field, 'values'])) {\n                // 用户通过 view.scale() 接口指定了 values 属性\n                appendConditions[field] = scaleDefs[field].values;\n            }\n        }\n        return group(data, groupFields, appendConditions);\n    };\n    // 数据调整前保存原始数据\n    Geometry.prototype.saveOrigin = function (data) {\n        return map(data, function (originData) {\n            var _a;\n            return __assign(__assign({}, originData), (_a = {}, _a[FIELD_ORIGIN] = originData, _a));\n        });\n    };\n    // 将分类数据翻译成数据, 仅对位置相关的度量进行数字化处理\n    Geometry.prototype.numeric = function (data) {\n        var positionAttr = this.getAttribute('position');\n        var scales = positionAttr.scales;\n        for (var j = 0, len = data.length; j < len; j += 1) {\n            var obj = data[j];\n            for (var i = 0; i < Math.min(2, scales.length); i += 1) {\n                var scale = scales[i];\n                if (scale.isCategory) {\n                    var field = scale.field;\n                    obj[field] = scale.translate(obj[field]);\n                }\n            }\n        }\n    };\n    // 更新发生层叠后的数据对应的度量范围\n    Geometry.prototype.updateStackRange = function (scale, dataArray) {\n        var mergeArray = flatten(dataArray);\n        var field = scale.field;\n        var min = scale.min;\n        var max = scale.max;\n        for (var _i = 0, mergeArray_1 = mergeArray; _i < mergeArray_1.length; _i++) {\n            var obj = mergeArray_1[_i];\n            var tmpMin = Math.min.apply(null, obj[field]);\n            var tmpMax = Math.max.apply(null, obj[field]);\n            if (tmpMin < min) {\n                min = tmpMin;\n            }\n            if (tmpMax > max) {\n                max = tmpMax;\n            }\n        }\n        var scaleDefs = this.scaleDefs;\n        var cfg = {};\n        if ((min < scale.min) && !get(scaleDefs, [field, 'min'])) {\n            // 用户如果在列定义中定义了 min，则以用户定义的为准\n            cfg.min = min;\n        }\n        if ((max > scale.max) && !get(scaleDefs, [field, 'max'])) {\n            // 用户如果在列定义中定义了 max\n            cfg.max = max;\n        }\n        scale.change(cfg);\n    };\n    // 将数据映射至图形空间前的操作：排序以及关键点的生成\n    Geometry.prototype.beforeMapping = function (beforeMappingData) {\n        var _this = this;\n        // 当初加 clone 是因为 points 的引用关系，导致更新失败，可是现在貌似复现不出来了，所以暂时不进行 clone\n        // const source = clone(beforeMappingData);\n        var source = beforeMappingData;\n        if (this.sortable) {\n            var xScale_2 = this.getXScale();\n            var field_1 = xScale_2.field;\n            each(source, function (data) {\n                data.sort(function (v1, v2) {\n                    return xScale_2.translate(v1[field_1]) - xScale_2.translate(v2[field_1]);\n                });\n            });\n        }\n        if (this.generatePoints) {\n            // 需要生成关键点\n            each(source, function (data) {\n                _this.generateShapePoints(data);\n            });\n            source.reduce(function (preData, currentData) {\n                preData[0].nextPoints = currentData[0].points;\n                return currentData;\n            }, source[0]);\n        }\n        return source;\n    };\n    // 映射完毕后，对最后的结果集进行排序，方便后续 tooltip 的数据查找\n    Geometry.prototype.afterMapping = function (mappingArray) {\n        if (!this.sortable) {\n            this.sort(mappingArray);\n        }\n        this.dataArray = mappingArray;\n    };\n    // 生成 shape 的关键点\n    Geometry.prototype.generateShapePoints = function (data) {\n        var shapeFactory = this.getShapeFactory();\n        var shapeAttr = this.getAttribute('shape');\n        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n            var obj = data_1[_i];\n            var cfg = this.createShapePointsCfg(obj);\n            var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;\n            var points = shapeFactory.getShapePoints(shape, cfg);\n            obj.points = points;\n        }\n    };\n    // 将数据归一化\n    Geometry.prototype.normalizeValues = function (values, scale) {\n        var rst = [];\n        if (isArray(values)) {\n            rst = values.map(function (v) { return scale.scale(v); });\n        }\n        else {\n            rst = scale.scale(values);\n        }\n        return rst;\n    };\n    // 将数据映射至图形空间\n    Geometry.prototype.mapping = function (data) {\n        var attributes = this.attributes;\n        var mappingData = [];\n        for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {\n            var record = data_2[_i];\n            var newRecord = {\n                _origin: record[FIELD_ORIGIN],\n                points: record.points,\n                nextPoints: record.nextPoints,\n            };\n            for (var k in attributes) {\n                if (attributes.hasOwnProperty(k)) {\n                    var attr = attributes[k];\n                    var names = attr.names;\n                    var values = this.getAttributeValues(attr, record);\n                    if (names.length > 1) {\n                        // position 之类的生成多个字段的属性\n                        for (var j = 0; j < values.length; j += 1) {\n                            var val = values[j];\n                            var name_1 = names[j];\n                            newRecord[name_1] = isArray(val) && val.length === 1 ? val[0] : val; // 只有一个值时返回第一个属性值\n                        }\n                    }\n                    else {\n                        // values.length === 1 的判断是以下情况，获取用户设置的图形属性值\n                        // shape('a', ['dot', 'dash']), color('a', ['red', 'yellow'])\n                        newRecord[names[0]] = values.length === 1 ? values[0] : values;\n                    }\n                }\n            }\n            this.convertPoint(newRecord); // 将 x、y 转换成画布坐标\n            mappingData.push(newRecord);\n        }\n        return mappingData;\n    };\n    // 将归一化的坐标值转换成画布坐标\n    Geometry.prototype.convertPoint = function (mappingRecord) {\n        var x = mappingRecord.x, y = mappingRecord.y;\n        if (isNil(x) || isNil(y)) {\n            return;\n        }\n        var rstX;\n        var rstY;\n        var obj;\n        var coordinate = this.coordinate;\n        if (isArray(y) && isArray(x)) {\n            rstX = [];\n            rstY = [];\n            for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {\n                obj = coordinate.convert({\n                    x: x[i],\n                    y: y[j],\n                });\n                rstX.push(obj.x);\n                rstY.push(obj.y);\n            }\n        }\n        else if (isArray(y)) {\n            rstY = [];\n            y.forEach(function (yVal) {\n                obj = coordinate.convert({\n                    x: x,\n                    y: yVal,\n                });\n                if (rstX && rstX !== obj.x) {\n                    if (!isArray(rstX)) {\n                        rstX = [rstX];\n                    }\n                    rstX.push(obj.x);\n                }\n                else {\n                    rstX = obj.x;\n                }\n                rstY.push(obj.y);\n            });\n        }\n        else if (isArray(x)) {\n            rstX = [];\n            x.forEach(function (xVal) {\n                obj = coordinate.convert({\n                    x: xVal,\n                    y: y,\n                });\n                if (rstY && rstY !== obj.y) {\n                    if (!isArray(rstY)) {\n                        rstY = [rstY];\n                    }\n                    rstY.push(obj.y);\n                }\n                else {\n                    rstY = obj.y;\n                }\n                rstX.push(obj.x);\n            });\n        }\n        else {\n            var point = coordinate.convert({\n                x: x,\n                y: y,\n            });\n            rstX = point.x;\n            rstY = point.y;\n        }\n        mappingRecord.x = rstX;\n        mappingRecord.y = rstY;\n    };\n    // 对数据进行排序\n    Geometry.prototype.sort = function (mappingArray) {\n        var xScale = this.getXScale();\n        var xField = xScale.field;\n        each(mappingArray, function (itemArr) {\n            itemArr.sort(function (obj1, obj2) {\n                return xScale.translate(obj1[FIELD_ORIGIN][xField]) - xScale.translate(obj2[FIELD_ORIGIN][xField]);\n            });\n        });\n    };\n    // 获取 style 配置\n    Geometry.prototype.getStyleCfg = function (styleOption, originData) {\n        var _a = styleOption.fields, fields = _a === void 0 ? [] : _a, callback = styleOption.callback, cfg = styleOption.cfg;\n        if (cfg) {\n            // 用户直接配置样式属性\n            return cfg;\n        }\n        var params = fields.map(function (field) {\n            return originData[field];\n        });\n        return callback.apply(void 0, params);\n    };\n    Geometry.prototype.setCfg = function (cfg) {\n        var _this = this;\n        var coordinate = cfg.coordinate, data = cfg.data, theme = cfg.theme, scaleDefs = cfg.scaleDefs;\n        if (coordinate) {\n            this.coordinate = coordinate;\n        }\n        if (data) {\n            this.data = data;\n        }\n        if (scaleDefs) {\n            this.scaleDefs = scaleDefs;\n            this.idFields = [];\n            each(scaleDefs, function (scaleDef, field) {\n                if (get(scaleDef, 'key')) {\n                    _this.idFields.push(field);\n                }\n            });\n        }\n        if (theme) {\n            this.theme = this.userTheme ? deepMix({}, theme, this.userTheme) : theme; // 支持 geometry 层级的主题设置\n        }\n    };\n    Geometry.prototype.renderLabels = function (mappingArray, isUpdate) {\n        if (isUpdate === void 0) { isUpdate = false; }\n        var geometryLabel = this.geometryLabel;\n        if (!geometryLabel) {\n            // 初次创建\n            var labelType = this.getLabelType();\n            var GeometryLabelsCtor = getGeometryLabel(labelType);\n            geometryLabel = new GeometryLabelsCtor(this);\n            this.geometryLabel = geometryLabel;\n        }\n        geometryLabel.render(mappingArray, isUpdate);\n        // 将 label 同 element 进行关联\n        var labelsMap = geometryLabel.labelsRenderer.shapesMap;\n        each(this.elementsMap, function (element, id) {\n            var labels = filterLabelsById(id, labelsMap); // element 实例同 label 进行绑定\n            element.labelShape = labels;\n            if (labels.length) {\n                each(labels, function (label) {\n                    var children = label.getChildren();\n                    each(children, function (child) {\n                        child.set('element', element);\n                    });\n                });\n            }\n        });\n    };\n    /**\n     * 是否需要进行群组入场动画\n     * 规则：\n     * 1. 如果发生更新，则不进行\n     * 2. 如果用户关闭 geometry 动画，则不进行\n     * 3. 如果用户关闭了 appear 动画，则不进行\n     * 4. 如果用户配置了 appear.animation，则不进行\n     */\n    Geometry.prototype.canDoGroupAnimation = function (isUpdate) {\n        return (!isUpdate &&\n            this.animateOption &&\n            (get(this.animateOption, 'appear') === undefined ||\n                (get(this.animateOption, 'appear') && get(this.animateOption, ['appear', 'animation']) === undefined)));\n    };\n    return Geometry;\n}(Base));\nexport default Geometry;\n//# sourceMappingURL=base.js.map"]},"metadata":{},"sourceType":"module"}